{"pages":[],"posts":[{"title":"3Sum","text":"題目思路： 用三個指標，iterate 最左邊那個，找出對應於每個 left 指標的所有 result 先把 nums 排序，如此移動 mid, right 指標時就有個依據 Python3 solution 1234567891011121314151617181920212223242526def threeSum(self, nums): result = [] nums.sort() for left in range(len(nums) - 2): # 右邊須留兩個空位給另兩個指標 if left &gt; 0 and nums[left] == nums[left - 1]: # 排除重複的 result，left 必須 &gt; 0 才會有前一個 continue # - 假如 nums[left] 是一樣的，最後找到的 result 也會是一樣的，所以要排除掉 mid = left + 1 right = len(nums) - 1 while mid &lt; right: # 設定有效範圍，在此範圍內尋找符合的 mid, right t_sum = nums[left] + nums[mid] + nums[right] if t_sum &lt; 0: mid += 1 # 此時必須讓 t_sum 變大，所以將 mid 往右移 elif t_sum &gt; 0: right -= 1 # 此時必須讓 t_sum 變小，所以將 right 往左移 else: result.append([nums[left], nums[mid], nums[right]]) while mid &lt; right and nums[mid] == nums[mid + 1]: # 跳過 mid 重複的部分 mid += 1 while mid &lt; right and nums[right] == nums[right - 1]: # 跳過 right 重複的部分 right -= 1 # 正常的移動 mid, right，尋找下一個符合的 result mid += 1 right -= 1 return result","link":"/2022/12/05/3-sum/"},{"title":"在 Mac 加入 ssh key 的步驟","text":"ssh-keygen -t ed25519 -C &quot;{你的 email}&quot; 預設路徑假如已有相同檔案，記得指定新的完整路徑 如檔名不用預設的，下面 id_ed25519 自行替換成自己的檔名 vi ~/.ssh/config 舉例：加上如下 1234Host GitHub HostName github.com IdentityFile ~/.ssh/id_ed25519 IdentitiesOnly yes ssh-add -K ~/.ssh/id_ed25519 pbcopy &lt; ~/.ssh/id_ed25519.pub 貼到所使用的服務網站的相對應設定頁面","link":"/2021/01/14/add-ssh-steps/"},{"title":"Add Two Numbers","text":"題目思路： 既然 Linked List 是由個位數開始，剛好可以用小學學的加法來從個位數開始相加。所以須設計一個迴圈來執行可重複執行的加法動作，一步步構建答案所需的 linked list，一次建立一個 node，直到完成。 迴圈要可重複執行，需要有個指標，在迴圈內對該指標所指的 node 做操作，並在迴圈結束時讓指標指到下一個 node，讓下一次迴圈來操作 迴圈內算出的當下位數的答案 digit_sum % 10 的 node 為何是指定給 curr.next 而非 curr? 因為迴圈結束前 curr 必須指向下一個 node，也就是 curr.next，以下分兩種情況解釋： 答案放在 curr 身上：必須創造一個空的 node 來當 curr.next，而假如這次的迴圈已經是最後一次了，此 linked list 的尾巴就會多一個空的 node 答案放在 curr.next 身上：迴圈結束前 curr 指向 curr.next 繼續下一次的操作，假如此次已是最後一次迴圈，也不會多出空的 node 在 linked list 末端，只會在開頭多出一個沒用到的 dummy_head 而已，因此最後回傳答案時是回傳 dummy_head.next Python3 solution 1234567891011121314def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: carry = 0 # 位數相加後除以 10 得到的商 dummy_head = ListNode() # 用 dummy_head 保留最前面的指標，到時候才有辦法回傳答案 curr = dummy_head # 不能只用 `curr = ListNode()`，因為 `curr` 所指的 node 必須一直變 while l1 or l2 or carry: # 可以繼續加的條件 v1 = l1 and l1.val or 0 v2 = l2 and l2.val or 0 digit_sum = v1 + v2 + carry carry = digit_sum // 10 curr.next = ListNode(digit_sum % 10) curr = curr.next l1 = l1 and l1.next l2 = l2 and l2.next return dummy_head.next","link":"/2023/02/03/add-two-numbers/"},{"title":"Balanced Binary Tree","text":"題目 做法一思路： 依照 height-balanced 的定義，需要符合每個node 的左右子樹高度差都不大於 1 假設有個 function height 可以回傳 node 的 height 先不實作內容 使用這個 height 完成 isBalanced 實作 height 的內容 Python3 solution: 123456789101112131415161718192021# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightdef isBalanced(self, root: Optional[TreeNode]) -&gt; bool: def height(node): if not node: # 終止條件 return 0 lh = height(node.left) rh = height(node.right) return max(lh, rh) + 1 if not root: # 終止條件 return True lh = height(root.left) rh = height(root.right) # 即使左右子樹高度差不大於一，子樹本身還是有可能是不平衡的，所以要再加上後面的 `isBalanced` 判斷 return abs(lh - rh) &lt;= 1 and self.isBalanced(root.left) and self.isBalanced(root.right) 假設有 n 個 node, 樹的高度為 h 時間複雜度：O(n^2) isBalanced 除了呼叫自己之外的複雜度為 O(n) 呼叫了 n - 1 次 height 每個節點都呼叫了一次 isBalanced 空間複雜度：O(h) 因為遞迴的呼叫有 DFS 的特性，會從子節點一直呼叫到最下面的葉子節點，所以需要把那些 function calls 放進 stack 裡，等到葉子節點的呼叫到了再一一拿出來執行。因此 stack 的大小需等於呼叫的次數，也就是由根節點走到葉子節點需經過幾個點，即這棵樹的高度 只需考慮一次遞迴呼叫所需空間，不需考慮全部遞迴呼叫 (譬如在 function 裡呼叫了自己兩次)，因為程式同時只會處理一個遞迴呼叫 做法二思路： 有沒有辦法優化上面做法的時間複雜度呢？因為上面在算高度的時候就已經會算出每個節點的左右子樹的高度了，此時就可以順便看看是否平衡，不用等到最後再遞迴呼叫 isBalanced 增加複雜度 Python3 solution: 12345678910111213def isBalanced(self, root: Optional[TreeNode]) -&gt; bool: self.balanced = True def height(node): if not node: return 0 lh = height(node.left) rh = height(node.right) if abs(lh - rh) &gt; 1: self.balanced = False return max(lh, rh) + 1 height(root) return self.balanced 假設有 n 個 node, 樹的高度為 h 時間複雜度：O(n) 每個節點都做過一次 height 空間複雜度：O(h) 同 做法一 的分析 類似題：Symmetric Tree 用 recursive 方法來解","link":"/2023/03/15/balanced-binary-tree/"},{"title":"簡單統整 JWT 相對於傳統 Session 驗證的好處","text":"Server 不用存 Session 只有在 Client 拿新 JWT 時才需要跟 DB 溝通 Clent 拿的時機：JWT 到期或第一次拿 為何不需跟 DB 溝通？ 因為 JWT 裡已有所需資訊 但假如業務需求需要另外取敏感資訊的話還是需要碰 DB 參考","link":"/2021/01/14/jwt-digest/"},{"title":"Merge Two Binary Trees","text":"題目 做法一：recursive - DFS 找出最小的可重複動作：merge 兩個 nodes 題目給的 method 就可以用來做遞迴 假設 mergeTrees 已完成，實作此最小可重複動作 1234root1.val += root2.valroot1.left = self.mergeTrees(root1.left, root2.left)root1.right = self.mergeTrees(root1.right, root2.right)return root1 寫出遞迴的終止條件 12if not root1 or not root2: return root1 or root2 Python3 solution: 12345678910111213# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightdef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]: if not root1 or not root2: return root1 or root2 root1.val += root2.val root1.left = self.mergeTrees(root1.left, root2.left) root1.right = self.mergeTrees(root1.right, root2.right) return root1 假設兩棵樹有較少節點的那顆有 n 個節點 時間複雜度：O(n) 空間複雜度：n 個節點那棵樹的深度 最差情況是 O(n), 平均為 O(log n) 做法二：iterative - BFS 準備一個 stack 來放待 merge 的 node pairs 一次從裡面拿一個 pair 出來 merge, 同時也把該 merge 的子節點 pair 丟進去。一直做到 stack 裡面沒東西為止 因為這邊是 merge 到 root1, 故最後回傳 root1 注意不要回傳到 p, 而是應該回傳當初的根節點 root1 Python3 solution: 12345678910111213141516171819202122# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightdef mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -&gt; Optional[TreeNode]: if not root1 or not root2: return root1 or root2 stack = [(root1, root2)] while stack: p, q = stack.pop() # 使用暫時的變數 p, q 來操作節點 merge p.val += q.val if not p.left and q.left: p.left = q.left elif p.left and q.left: stack.append((p.left, q.left)) if not p.right and q.right: p.right = q.right elif p.right and q.right: stack.append((p.right, q.right)) return root1 假設兩棵樹有較少節點的那顆有 n 個節點 時間複雜度：O(n) stack 裡會有 n 個 pairs, 所以會做 n 次 空間複雜度：O(n) 需要大小為 n 的 stack","link":"/2023/03/16/merge-two-binary-trees/"},{"title":"Merge Two Sorted Lists","text":"題目思路： 因為要做一個 linked list，可以用 while 在每次迴圈都接一個 node 出來 先設 while True:，等寫迴圈內容時再來確定 while 可繼續執行的條件 寫第一 part (如下) 後發現，while 條件需要 l1 and l2 123456if l1.val &gt; l2.val: curr.next = l2 l2 = l2.nextelse: curr.next = l1 l1 = l1.next post processing: 跳出迴圈後的情形是 l1, l2 其中有一個是 None 或兩個都是 None，此時就把目標 linked list 接上那個不是 None 的即可 Python3 solution: 12345678910111213def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: dummy_head = ListNode() # 需有一個 dummy_head 可以在最後回傳答案時使用 curr = dummy_head # 也要有個 curr 可以在每次迴圈中跟著移動 while l1 and l2: if l1.val &gt; l2.val: curr.next = l2 l2 = l2.next else: curr.next = l1 l1 = l1.next curr = curr.next curr.next = l1 or l2 # post processing return dummy_head.next P.S. 有些思路跟 Add Two Numbers 重複，這篇就不多寫了","link":"/2023/02/09/merge-two-sorted-lists/"},{"title":"用 pipenv 管理 requirements 搭配 docker-compose local 開發","text":"Local 開發是跑在 Docker 的虛擬環境裡，所以 Pipenv 產生的虛擬環境只是用來裝套件產生 Pipfile.lock 而已 用 pipenv 就不用自己寫 requirements.txt，不但可以自動安裝最新版的套件，而且可以很輕鬆的固定住對應 sub-packages 的版本 想一次更新所有套件也很容易 步驟：(以裝一個 package 為例) pip install --user pipenv 裝完後 command line 找不到 pipenv 的需把對應資料夾加入 PATH cd 到專案資料夾 pipenv install {target-package} 假如原本沒有 virtual environment，pipenv 會先幫你產生一個基於這個資料夾的 virtual environment 假如上層資料夾有 Pipfile，pipenv 會直接用那個 Pipfile 的 virtual environment，不會產生新的 這是因為 pipenv 的虛擬環境是 project base 的，所以你可以在一個 Django project 裡的任何一個資料夾執行 pipenv 都可以用到這個 project 的虛擬環境 而且正常情況下不會有 Django project 裡還有 Django project 的情況，所以不需要在上層已有 Pipfile 的情況下，又在目前資料夾產生 Pipfile 這邊不要指定版號，pipenv 就會安裝最新版 pipenv 會產生 Pipfile 和 Pipfile.lock, 後者有記錄這個 package 和 sub-packages 的固定版號 pipenv lock -r &gt; requirements.txt 將 Pipfile.lock 輸出為 requirements.txt 格式 接著就可以在 Dockerfile 裡直接用這個 requirements.txt 啦 如果要開新的 Django project: cd {你想要 project 資料夾放的位置} mkdir {project-name}; cd {project-name} pipenv install Django pipenv run django-admin startproject {project-name} . .: 要把 manage.py 放在當前資料夾 之後假如要把 requirements.txt 裡所有的 top-level 套件都更新的話: pipenv update 這個我自己沒試過，不過看文件應該是用這指令 重新輸出 requirements.txt 有看到另一種做法是可以不用自己產生 requirements.txt，直接在 Dockerfile 裡用 pipenv 動態生成 requirements.txt 來用，不過我自己還沒試過 Ref.","link":"/2020/02/06/pipenv-intro/"},{"title":"PostgreSQL/MySQL local docker 開發的初始 setup","text":"container run 起來之後：PostgreSQL: docker exec -it {db-container-name} psql -U postgres 以預設 user postgres 連進 DB create user {username} with password '{password}'; create database {database_name} with owner {username}; 大功告成，可以用 \\l 列出所有 database &amp; \\du 列出所有 user 來確認 P.S. 假如一開始忘了指定 database owner 或想改變 owner: alter database {database_name} owner to {owner_name}; MySQL: (以 5.7 為例) 環境變數須設置 MYSQL_ROOT_PASSWORD docker exec -it {db-container-name} mysql -p 以預設 user root 連進去，輸入上面環境變數設置的密碼 create user '{username}'@'localhost' identified by '{password}'; Use localhost due to working on the machine with MySQL. create database {database_name}; 確認： show databases; SELECT user FROM mysql.user;","link":"/2020/02/07/postgresql-mysql-init-setup/"},{"title":"Remove Duplicates from Sorted List","text":"題目思路： 既然是 Linked List，我們可以宣告一個指標 curr 指向第一個 node，用 while 迴圈一次檢查一個 node (檢查完將指標移到下一個 node) 不能直接用 head 來移動，因為到時候回傳答案的時候需要回傳這個 head 設定 while 可以繼續檢查的條件：有時要先寫 while 的內容，才會比較確定 while 條件應該怎麼寫，這時可以先寫 while True:，等內容寫完再來改條件 寫 while 內容 假如 curr.val 跟下一個一樣，就把 next 接到下下個 12if curr.val == curr.next.val: curr.next = curr.next.next 但假如下下個也一樣呢？=&gt; 把上面的 if 改成 while，讓最後 curr.next 所指的 val 一定是不一樣的 改成 while 之後，檢查條件會被重複執行。因為 curr.next 有可能會是 None，所以條件改為while curr.val == (curr.next and curr.next.val): 離開 while 之後：curr = curr.next # 把指標移到下一個 node，以便下次的檢查 回去修改 while 條件：什麼條件成立我們才能繼續檢查(執行 while 內容)？ 首先 curr 不能是 None curr 有可能是 None，因為我們一直把它指向下一個 Node，到了盡頭 curr 就會是 None 即使 curr.next 是 None，還是可以順利執行迴圈內容 結論：條件為 while curr: 離開 while 之後就大功告成，回傳答案 head Python3 solution: 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextdef deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: curr = head # 等一下可以在 while 迴圈中移動的指標 while curr: while curr.val == (curr.next and curr.next.val): curr.next = curr.next.next curr = curr.next return head","link":"/2023/02/09/remove-duplicates-from-sorted-list/"},{"title":"Same Tree","text":"題目思路： 要比較所有相同位置的 node 的值是否一樣，可以把所有待比較的 node pair 丟到 stack 裡一一拿出來比較，全部比完都通過的話就是一樣的 tree 一個 pair 比較後會把下面的所有分支點繼續丟進 stack 等待比較，所以用 while stack: 只要有就繼續比，一直比到完 此為廣先搜尋 (Breadth-First Search) Python3 solution: 123456789101112131415161718# Definition for a binary tree node.# class TreeNode:# def __init__(self, val=0, left=None, right=None):# self.val = val# self.left = left# self.right = rightdef isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -&gt; bool: stack = [(p, q)] while stack: p, q = stack.pop() if p and q and p.val == q.val: stack.extend([ (p.left, q.left), (p.right, q.right) ]) elif p or q: # 只有在 p, q 都是 None 的情況下才會通過，這代表這兩棵樹在那個位置都沒有葉子 return False return True 假設 p 有 n 個節點，寬度 w1，q 有 m 個節點，寬度 w2 時間複雜度：O(max(m, n)) 空間複雜度：O(max(w1, w2)) 因為是 BFS, stack 需儲存當前層次上的節點，故跟寬度成正比 類似題：Symmetric Tree 用 iterative 方法來解","link":"/2023/02/10/same-tree/"},{"title":"Unique Paths","text":"題目思路 每走一步都會是一個 unique path，到終點的路線是由每一步所組成的，所以可以用遞迴的方式來想，最小的可重複動作就是一步，點 (i, j) 到終點的 unique path count 就是 (i + 1, j) 和 (i, j + 1) 的 unique path count 的和 最小可重複動作 return u_paths(i + 1, j) + u_paths(i, j + 1) 終止條件 1234if i &gt;= m or j &gt;= n: return 0if i == m - 1 and j == n - 1: return 1 已經在終點上了，unique path count 卻是 1，一開始可能會覺得有點怪，不過從終點左邊那個點來想，就不會怪了： 左邊那個點的 unique path count = (它的下面那點的 path count) + (它右邊那點的 path count) 下面那點：path count 為 0 右邊那點 (終點)：path count 必須是 1 遞迴解法如下，但時間複雜度太大了 123456789101112131415def uniquePaths(self, m: int, n: int) -&gt; int: def u_paths(i, j): &quot;&quot;&quot; i, j 為從 0 開始的坐標 @return 由 (i, j) 走到終點的 unique path count &quot;&quot;&quot; # 終止條件 if i &gt;= m or j &gt;= n: return 0 if i == m - 1 and j == n - 1: return 1 # 最小可重複動作 return u_paths(i + 1, j) + u_paths(i, j + 1) return u_paths(0, 0) 看到兩個解法都說時間複雜度是 O(2^(m + n))，但一個沒講為啥，一個的解釋無法說服我，之後有空再來研究。 因為同一個點可能會走到很多次，我們可以把結果存在二維陣列，避免重複計算，以減少時間複雜度 Python3 solution: 12345678910111213141516171819202122def uniquePaths(self, m: int, n: int) -&gt; int: dp = [[None] * n for i in range(m)] # m * n 的二維陣列 def u_paths(i, j): &quot;&quot;&quot; i, j 為從 0 開始的坐標 @return 由 (i, j) 走到終點的 unique path count &quot;&quot;&quot; # 終止條件 if i &gt;= m or j &gt;= n: return 0 if i == m - 1 and j == n - 1: return 1 if dp[i][j]: return dp[i][j] # 最小可重複動作 dp[i][j] = u_paths(i + 1, j) + u_paths(i, j + 1) return dp[i][j] return u_paths(0, 0) 時間複雜度：O(m * n) 因為有記憶，每個點只會計算一次，共有 m * n 個點 空間複雜度：O(m * n) 維護 dp 所需空間。遞迴呼叫所需空間 m 和 n 可忽略 類似題： Fibonacci Number Unique Paths II","link":"/2023/03/18/unique-paths/"},{"title":"Search Insert Position","text":"題目思路：最直覺是直接 iterate nums，不過題目指定要 O(log n)，所以用 binary search 才能達到 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: 設定 binary search 可繼續執行的條件 此時會想，要用 &lt; or &lt;= 呢？判斷依據為在迴圈裡變更完 left or right 之後，不能造成無窮迴圈 但此時還沒寫迴圈內容，所以可以先直觀的設定一個，譬如 &lt;，等寫完迴圈內容再來驗證是否適合 迴圈寫完後，回來 check while condition，看看 while 把 left &amp; right 收斂到最後幾個的時候，經過以下的操作會不會有無窮迴圈 121. left = mid + 12. right = mid 剩最後三個：此時 mid 會是中間那個，上面兩種操作都有助於收斂範圍 剩最後兩個：此時 mid == left，上面兩種操作一樣可以收斂範圍 剩最後一個：此時 left == mid == right，以目前的 while 條件設定，會因為不符而跳出，所以跳出迴圈後的情況就是這個 如果 while 條件為 left &lt;= right，則 right = mid 這個操作會造成無窮迴圈，因此不能設定為 &lt;= =&gt; 確認不會造成無窮迴圈，所以此 while 條件設定是正確的 Post processing: 跳出 while 後的情況為 left == right，此時再跟 target 比，決定答案為何 為何跳出 while 後的情況不會是 left &gt; right? 要讓 left &gt; right，必須執行到 left = mid + 1，而且此時 left 和 right 都必須等於 mid，而如果已經是這個情況，就不會再進到迴圈裡，而是已經跳出了 Python3 solution: 1234567891011def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 # 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: mid = (left + right) // 2 # Python3 不會有 integer overflow 的問題，所以可以直接 (left + right)，然後用 `//` 無條件捨去，避免小數 if nums[mid] == target: return mid if nums[mid] &lt; target: left = mid + 1 # 此時最小的可能答案為 `mid + 1` else: right = mid # 此時最大的可能答案為 `mid` return left + 1 if nums[left] &lt; target else left 更詳細解說可參考此篇文章 類似題：First Bad Version延伸題：Find Peak Element","link":"/2022/12/08/search-insert-position/"},{"title":"為什麼 Python dict 的 get item operation 時間複雜度為 O(1) ？","text":"如果去 google，大部分查到的都會說因為 Python 會把 key 經過 hash function 運算，得到一個 dict 真正內部在使用的 key，從而找到對應的 value。而一個好的 hash function 它的運算所需時間是不會隨著 n 增加而變大的，所以 dict 的 get item operation 時間複雜度為 O(1) 。 不過我的疑惑是，經過 hash function 運算得到 key 之後，由這個 key 去找到 value 的時間複雜度是 O(1) 嗎？除非這個也是 O(1) 才能說整個 get item operation 是 O(1) 。 後來再多翻了一些說明，終於看到一兩個回答可以解釋這個疑惑。可以想像成今天我們有一個 array，我們只要知道 index 就可以知道要去哪裡找到對應的 value ( 因此是 O(1) )，經由 hash function 算出來的 key 就好像 array 的 index 一樣，只要看到這個 key 就知道要去哪裡找對應的 value，不會受 n 大小的影響，所以是 O(1) 另一個比較生活化的例子：hash function 算出來的 key，就好像你在圖書館要找書時用的索引，看到索引你就會知道書在哪一區、哪個櫃子裡，即使你需要照著圖書館的索引指示找一下才能找到，但這個過程所花的時間，跟圖書館有多少書沒有關係。 References: https://qr.ae/pvMCpM https://qr.ae/pvMCIv","link":"/2022/07/25/why-dict-o1/"}],"tags":[{"name":"array","slug":"array","link":"/tags/array/"},{"name":"two pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"},{"name":"linked list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"depth-first search","slug":"depth-first-search","link":"/tags/depth-first-search/"},{"name":"binary tree","slug":"binary-tree","link":"/tags/binary-tree/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"breadth-first search","slug":"breadth-first-search","link":"/tags/breadth-first-search/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"dynamic programming","slug":"dynamic-programming","link":"/tags/dynamic-programming/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"Authentication","slug":"Authentication","link":"/categories/Authentication/"},{"name":"Package Management","slug":"Package-Management","link":"/categories/Package-Management/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}