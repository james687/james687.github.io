{"pages":[],"posts":[{"title":"簡單統整 JWT 相對於傳統 Session 驗證的好處","text":"Server 不用存 Session 只有在 Client 拿新 JWT 時才需要跟 DB 溝通 Clent 拿的時機：JWT 到期或第一次拿 為何不需跟 DB 溝通？ 因為 JWT 裡已有所需資訊 但假如業務需求需要另外取敏感資訊的話還是需要碰 DB 參考","link":"/2021/01/14/jwt-digest/"},{"title":"在 Mac 加入 ssh key 的步驟","text":"ssh-keygen -t ed25519 -C &quot;{你的 email}&quot; 預設路徑假如已有相同檔案，記得指定新的完整路徑 如檔名不用預設的，下面 id_ed25519 自行替換成自己的檔名 vi ~/.ssh/config 舉例：加上如下 1234Host GitHub HostName github.com IdentityFile ~/.ssh/id_ed25519 IdentitiesOnly yes ssh-add -K ~/.ssh/id_ed25519 pbcopy &lt; ~/.ssh/id_ed25519.pub 貼到所使用的服務網站的相對應設定頁面","link":"/2021/01/14/add-ssh-steps/"},{"title":"PostgreSQL local docker 開發的初始 setup","text":"為了讓 web framework 可以跟你的 DB 連線，在你的 PostgreSQL container run 起來之後： docker exec -it {db-container-name} psql -U postgres 以預設 user postgres 連進 DB create user {username} with password '{password}'; create database {database_name} with owner {username}; 大功告成，可以用 \\l 列出所有 database &amp; \\du 列出所有 user 來確認 P.S. 假如一開始忘了指定 database owner 或想改變 owner: alter database {database_name} owner to {owner_name};","link":"/2020/02/07/postgresql-init-setup/"},{"title":"為什麼 Python dict 的 get item operation 時間複雜度為 O(1) ？","text":"如果去 google，大部分查到的都會說因為 Python 會把 key 經過 hash function 運算，得到一個 dict 真正內部在使用的 key，從而找到對應的 value。而一個好的 hash function 它的運算所需時間是不會隨著 n 增加而變大的，所以 dict 的 get item operation 時間複雜度為 O(1) 。 不過我的疑惑是，經過 hash function 運算得到 key 之後，由這個 key 去找到 value 的時間複雜度是 O(1) 嗎？除非這個也是 O(1) 才能說整個 get item operation 是 O(1) 。 後來再多翻了一些說明，終於看到一兩個回答可以解釋這個疑惑。可以想像成今天我們有一個 array，我們只要知道 index 就可以知道要去哪裡找到對應的 value ( 因此是 O(1) )，經由 hash function 算出來的 key 就好像 array 的 index 一樣，只要看到這個 key 就知道要去哪裡找對應的 value，不會受 n 大小的影響，所以是 O(1) 另一個比較生活化的例子：hash function 算出來的 key，就好像你在圖書館要找書時用的索引，看到索引你就會知道書在哪一區、哪個櫃子裡，即使你需要照著圖書館的索引指示找一下才能找到，但這個過程所花的時間，跟圖書館有多少書沒有關係。 References: https://qr.ae/pvMCpM https://qr.ae/pvMCIv","link":"/2022/07/25/why-dict-o1/"},{"title":"用 pipenv 管理 requirements 搭配 docker-compose local 開發","text":"Local 開發是跑在 Docker 的虛擬環境裡，所以 Pipenv 產生的虛擬環境只是用來裝套件產生 Pipfile.lock 而已 用 pipenv 就不用自己寫 requirements.txt，不但可以自動安裝最新版的套件，而且可以很輕鬆的固定住對應 sub-packages 的版本 想一次更新所有套件也很容易 步驟：(以裝一個 package 為例) pip install --user pipenv 裝完後 command line 找不到 pipenv 的需把對應資料夾加入 PATH cd 到專案資料夾 pipenv install {target-package} 假如原本沒有 virtual environment，pipenv 會先幫你產生一個基於這個資料夾的 virtual environment 假如上層資料夾有 Pipfile，pipenv 會直接用那個 Pipfile 的 virtual environment，不會產生新的 這是因為 pipenv 的虛擬環境是 project base 的，所以你可以在一個 Django project 裡的任何一個資料夾執行 pipenv 都可以用到這個 project 的虛擬環境 而且正常情況下不會有 Django project 裡還有 Django project 的情況，所以不需要在上層已有 Pipfile 的情況下，又在目前資料夾產生 Pipfile 這邊不要指定版號，pipenv 就會安裝最新版 pipenv 會產生 Pipfile 和 Pipfile.lock, 後者有記錄這個 package 和 sub-packages 的固定版號 pipenv lock -r &gt; requirements.txt 將 Pipfile.lock 輸出為 requirements.txt 格式 接著就可以在 Dockerfile 裡直接用這個 requirements.txt 啦 如果要開新的 Django project: cd {你想要 project 資料夾放的位置} mkdir {project-name}; cd {project-name} pipenv install Django pipenv run django-admin startproject {project-name} . .: 要把 manage.py 放在當前資料夾 之後假如要把 requirements.txt 裡所有的 top-level 套件都更新的話: pipenv update 這個我自己沒試過，不過看文件應該是用這指令 重新輸出 requirements.txt 有看到另一種做法是可以不用自己產生 requirements.txt，直接在 Dockerfile 裡用 pipenv 動態生成 requirements.txt 來用，不過我自己還沒試過 Ref.","link":"/2020/02/06/pipenv-intro/"}],"tags":[{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"django","slug":"django","link":"/tags/django/"}],"categories":[{"name":"Authentication","slug":"Authentication","link":"/categories/Authentication/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Package Management","slug":"Package-Management","link":"/categories/Package-Management/"}]}