{"pages":[],"posts":[{"title":"Merge Two Sorted Lists","text":"題目思路： 因為要做一個 linked list，可以用 while 在每次迴圈都接一個 node 出來 先設 while True:，等寫迴圈內容時再來確定 while 可繼續執行的條件 寫第一 part (如下) 後發現，while 條件需要 l1 and l2 123456if l1.val &gt; l2.val: curr.next = l2 l2 = l2.nextelse: curr.next = l1 l1 = l1.next post processing: 跳出迴圈後的情形是 l1, l2 其中有一個是 None 或兩個都是 None，此時就把目標 linked list 接上那個不是 None 的即可 Python3 solution: 12345678910111213def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: dummy_head = ListNode() # 需有一個 dummy_head 可以在最後回傳答案時使用 curr = dummy_head # 也要有個 curr 可以在每次迴圈中跟著移動 while l1 and l2: if l1.val &gt; l2.val: curr.next = l2 l2 = l2.next else: curr.next = l1 l1 = l1.next curr = curr.next curr.next = l1 or l2 # post processing return dummy_head.next P.S. 有些思路跟 Add Two Numbers 重複，這篇就不多寫了","link":"/2023/02/09/merge-two-sorted-lists/"},{"title":"簡單統整 JWT 相對於傳統 Session 驗證的好處","text":"Server 不用存 Session 只有在 Client 拿新 JWT 時才需要跟 DB 溝通 Clent 拿的時機：JWT 到期或第一次拿 為何不需跟 DB 溝通？ 因為 JWT 裡已有所需資訊 但假如業務需求需要另外取敏感資訊的話還是需要碰 DB 參考","link":"/2021/01/14/jwt-digest/"},{"title":"Remove Duplicates from Sorted List","text":"題目思路： 既然是 Linked List，我們可以宣告一個指標 curr 指向第一個 node，用 while 迴圈一次檢查一個 node (檢查完將指標移到下一個 node) 不能直接用 head 來移動，因為到時候回傳答案的時候需要回傳這個 head 設定 while 可以繼續檢查的條件：有時要先寫 while 的內容，才會比較確定 while 條件應該怎麼寫，這時可以先寫 while True:，等內容寫完再來改條件 寫 while 內容 假如 curr.val 跟下一個一樣，就把 next 接到下下個 12if curr.val == curr.next.val: curr.next = curr.next.next 但假如下下個也一樣呢？=&gt; 把上面的 if 改成 while，讓最後 curr.next 所指的 val 一定是不一樣的 改成 while 之後，檢查條件會被重複執行。因為 curr.next 有可能會是 None，所以條件改為while curr.val == (curr.next and curr.next.val): 離開 while 之後：curr = curr.next # 把指標移到下一個 node，以便下次的檢查 回去修改 while 條件：什麼條件成立我們才能繼續檢查(執行 while 內容)？ 首先 curr 不能是 None curr 有可能是 None，因為我們一直把它指向下一個 Node，到了盡頭 curr 就會是 None 即使 curr.next 是 None，還是可以順利執行迴圈內容 結論：條件為 while curr: 離開 while 之後就大功告成，回傳答案 head Python3 solution: 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, val=0, next=None):# self.val = val# self.next = nextdef deleteDuplicates(self, head: Optional[ListNode]) -&gt; Optional[ListNode]: curr = head # 等一下可以在 while 迴圈中移動的指標 while curr: while curr.val == (curr.next and curr.next.val): curr.next = curr.next.next curr = curr.next return head","link":"/2023/02/09/remove-duplicates-from-sorted-list/"},{"title":"在 Mac 加入 ssh key 的步驟","text":"ssh-keygen -t ed25519 -C &quot;{你的 email}&quot; 預設路徑假如已有相同檔案，記得指定新的完整路徑 如檔名不用預設的，下面 id_ed25519 自行替換成自己的檔名 vi ~/.ssh/config 舉例：加上如下 1234Host GitHub HostName github.com IdentityFile ~/.ssh/id_ed25519 IdentitiesOnly yes ssh-add -K ~/.ssh/id_ed25519 pbcopy &lt; ~/.ssh/id_ed25519.pub 貼到所使用的服務網站的相對應設定頁面","link":"/2021/01/14/add-ssh-steps/"},{"title":"用 pipenv 管理 requirements 搭配 docker-compose local 開發","text":"Local 開發是跑在 Docker 的虛擬環境裡，所以 Pipenv 產生的虛擬環境只是用來裝套件產生 Pipfile.lock 而已 用 pipenv 就不用自己寫 requirements.txt，不但可以自動安裝最新版的套件，而且可以很輕鬆的固定住對應 sub-packages 的版本 想一次更新所有套件也很容易 步驟：(以裝一個 package 為例) pip install --user pipenv 裝完後 command line 找不到 pipenv 的需把對應資料夾加入 PATH cd 到專案資料夾 pipenv install {target-package} 假如原本沒有 virtual environment，pipenv 會先幫你產生一個基於這個資料夾的 virtual environment 假如上層資料夾有 Pipfile，pipenv 會直接用那個 Pipfile 的 virtual environment，不會產生新的 這是因為 pipenv 的虛擬環境是 project base 的，所以你可以在一個 Django project 裡的任何一個資料夾執行 pipenv 都可以用到這個 project 的虛擬環境 而且正常情況下不會有 Django project 裡還有 Django project 的情況，所以不需要在上層已有 Pipfile 的情況下，又在目前資料夾產生 Pipfile 這邊不要指定版號，pipenv 就會安裝最新版 pipenv 會產生 Pipfile 和 Pipfile.lock, 後者有記錄這個 package 和 sub-packages 的固定版號 pipenv lock -r &gt; requirements.txt 將 Pipfile.lock 輸出為 requirements.txt 格式 接著就可以在 Dockerfile 裡直接用這個 requirements.txt 啦 如果要開新的 Django project: cd {你想要 project 資料夾放的位置} mkdir {project-name}; cd {project-name} pipenv install Django pipenv run django-admin startproject {project-name} . .: 要把 manage.py 放在當前資料夾 之後假如要把 requirements.txt 裡所有的 top-level 套件都更新的話: pipenv update 這個我自己沒試過，不過看文件應該是用這指令 重新輸出 requirements.txt 有看到另一種做法是可以不用自己產生 requirements.txt，直接在 Dockerfile 裡用 pipenv 動態生成 requirements.txt 來用，不過我自己還沒試過 Ref.","link":"/2020/02/06/pipenv-intro/"},{"title":"PostgreSQL/MySQL local docker 開發的初始 setup","text":"container run 起來之後：PostgreSQL: docker exec -it {db-container-name} psql -U postgres 以預設 user postgres 連進 DB create user {username} with password '{password}'; create database {database_name} with owner {username}; 大功告成，可以用 \\l 列出所有 database &amp; \\du 列出所有 user 來確認 P.S. 假如一開始忘了指定 database owner 或想改變 owner: alter database {database_name} owner to {owner_name}; MySQL: (以 5.7 為例) 環境變數須設置 MYSQL_ROOT_PASSWORD docker exec -it {db-container-name} mysql -p 以預設 user root 連進去，輸入上面環境變數設置的密碼 create user '{username}'@'localhost' identified by '{password}'; Use localhost due to working on the machine with MySQL. create database {database_name}; 確認： show databases; SELECT user FROM mysql.user;","link":"/2020/02/07/postgresql-mysql-init-setup/"},{"title":"為什麼 Python dict 的 get item operation 時間複雜度為 O(1) ？","text":"如果去 google，大部分查到的都會說因為 Python 會把 key 經過 hash function 運算，得到一個 dict 真正內部在使用的 key，從而找到對應的 value。而一個好的 hash function 它的運算所需時間是不會隨著 n 增加而變大的，所以 dict 的 get item operation 時間複雜度為 O(1) 。 不過我的疑惑是，經過 hash function 運算得到 key 之後，由這個 key 去找到 value 的時間複雜度是 O(1) 嗎？除非這個也是 O(1) 才能說整個 get item operation 是 O(1) 。 後來再多翻了一些說明，終於看到一兩個回答可以解釋這個疑惑。可以想像成今天我們有一個 array，我們只要知道 index 就可以知道要去哪裡找到對應的 value ( 因此是 O(1) )，經由 hash function 算出來的 key 就好像 array 的 index 一樣，只要看到這個 key 就知道要去哪裡找對應的 value，不會受 n 大小的影響，所以是 O(1) 另一個比較生活化的例子：hash function 算出來的 key，就好像你在圖書館要找書時用的索引，看到索引你就會知道書在哪一區、哪個櫃子裡，即使你需要照著圖書館的索引指示找一下才能找到，但這個過程所花的時間，跟圖書館有多少書沒有關係。 References: https://qr.ae/pvMCpM https://qr.ae/pvMCIv","link":"/2022/07/25/why-dict-o1/"},{"title":"Search Insert Position","text":"題目思路：最直覺是直接 iterate nums，不過題目指定要 O(log n)，所以用 binary search 才能達到 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: 設定 binary search 可繼續執行的條件 此時會想，要用 &lt; or &lt;= 呢？判斷依據為在迴圈裡變更完 left or right 之後，不能造成無窮迴圈 但此時還沒寫迴圈內容，所以可以先直觀的設定一個，譬如 &lt;，等寫完迴圈內容再來驗證是否適合 迴圈寫完後，回來 check while condition，看看 while 把 left &amp; right 收斂到最後幾個的時候，經過以下的操作會不會有無窮迴圈 121. left = mid + 12. right = mid 剩最後三個：此時 mid 會是中間那個，上面兩種操作都有助於收斂範圍 剩最後兩個：此時 mid == left，上面兩種操作一樣可以收斂範圍 剩最後一個：此時 left == mid == right，以目前的 while 條件設定，會因為不符而跳出，所以跳出迴圈後的情況就是這個 如果 while 條件為 left &lt;= right，則 right = mid 這個操作會造成無窮迴圈，因此不能設定為 &lt;= =&gt; 確認不會造成無窮迴圈，所以此 while 條件設定是正確的 Post processing: 跳出 while 後的情況為 left == right，此時再跟 target 比，決定答案為何 為何跳出 while 後的情況不會是 left &gt; right? 要讓 left &gt; right，必須執行到 left = mid + 1，而且此時 left 和 right 都必須等於 mid，而如果已經是這個情況，就不會再進到迴圈裡，而是已經跳出了 Python3 solution: 1234567891011def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 # 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: mid = (left + right) // 2 # Python3 不會有 integer overflow 的問題，所以可以直接 (left + right)，然後用 `//` 無條件捨去，避免小數 if nums[mid] == target: return mid if nums[mid] &lt; target: left = mid + 1 # 此時最小的可能答案為 `mid + 1` else: right = mid # 此時最大的可能答案為 `mid` return left + 1 if nums[left] &lt; target else left 更詳細解說可參考此篇文章 類似題：First Bad Version延伸題：Find Peak Element","link":"/2022/12/08/search-insert-position/"},{"title":"3Sum","text":"題目思路： 用三個指標，iterate 最左邊那個，找出對應於每個 left 指標的所有 result 先把 nums 排序，如此移動 mid, right 指標時就有個依據 Python3 solution 1234567891011121314151617181920212223242526def threeSum(self, nums): result = [] nums.sort() for left in range(len(nums) - 2): # 右邊須留兩個空位給另兩個指標 if left &gt; 0 and nums[left] == nums[left - 1]: # 排除重複的 result，left 必須 &gt; 0 才會有前一個 continue # - 假如 nums[left] 是一樣的，最後找到的 result 也會是一樣的，所以要排除掉 mid = left + 1 right = len(nums) - 1 while mid &lt; right: # 設定有效範圍，在此範圍內尋找符合的 mid, right t_sum = nums[left] + nums[mid] + nums[right] if t_sum &lt; 0: mid += 1 # 此時必須讓 t_sum 變大，所以將 mid 往右移 elif t_sum &gt; 0: right -= 1 # 此時必須讓 t_sum 變小，所以將 right 往左移 else: result.append([nums[left], nums[mid], nums[right]]) while mid &lt; right and nums[mid] == nums[mid + 1]: # 跳過 mid 重複的部分 mid += 1 while mid &lt; right and nums[right] == nums[right - 1]: # 跳過 right 重複的部分 right -= 1 # 正常的移動 mid, right，尋找下一個符合的 result mid += 1 right -= 1 return result","link":"/2022/12/05/3-sum/"},{"title":"Add Two Numbers","text":"題目思路： 既然 Linked List 是由個位數開始，剛好可以用小學學的加法來從個位數開始相加。所以須設計一個迴圈來執行可重複執行的加法動作，一步步構建答案所需的 linked list，一次建立一個 node，直到完成。 迴圈要可重複執行，需要有個指標，在迴圈內對該指標所指的 node 做操作，並在迴圈結束時讓指標指到下一個 node，讓下一次迴圈來操作 迴圈內算出的當下位數的答案 digit_sum % 10 的 node 為何是指定給 curr.next 而非 curr? 因為迴圈結束前 curr 必須指向下一個 node，也就是 curr.next，以下分兩種情況解釋： 答案放在 curr 身上：必須創造一個空的 node 來當 curr.next，而假如這次的迴圈已經是最後一次了，此 linked list 的尾巴就會多一個空的 node 答案放在 curr.next 身上：迴圈結束前 curr 指向 curr.next 繼續下一次的操作，假如此次已是最後一次迴圈，也不會多出空的 node 在 linked list 末端，只會在開頭多出一個沒用到的 dummy_head 而已，因此最後回傳答案時是回傳 dummy_head.next Python3 solution 1234567891011121314def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]: carry = 0 # 位數相加後除以 10 得到的商 dummy_head = ListNode() # 用 dummy_head 保留最前面的指標，到時候才有辦法回傳答案 curr = dummy_head # 不能只用 `curr = ListNode()`，因為 `curr` 所指的 node 必須一直變 while l1 or l2 or carry: # 可以繼續加的條件 v1 = l1 and l1.val or 0 v2 = l2 and l2.val or 0 digit_sum = v1 + v2 + carry carry = digit_sum // 10 curr.next = ListNode(digit_sum % 10) curr = curr.next l1 = l1 and l1.next l2 = l2 and l2.next return dummy_head.next","link":"/2023/02/03/add-two-numbers/"}],"tags":[{"name":"linked list","slug":"linked-list","link":"/tags/linked-list/"},{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"django","slug":"django","link":"/tags/django/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"two pointers","slug":"two-pointers","link":"/tags/two-pointers/"},{"name":"sorting","slug":"sorting","link":"/tags/sorting/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"Authentication","slug":"Authentication","link":"/categories/Authentication/"},{"name":"Package Management","slug":"Package-Management","link":"/categories/Package-Management/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}