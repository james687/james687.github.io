{"pages":[],"posts":[{"title":"3Sum note","text":"題目思路： 用三個指標，iterate 最左邊那個，找出對應於每個 left 指標的所有 result 先把 nums 排序，如此移動 mid, right 指標時就有個依據 Python3 solution 1234567891011121314151617181920212223242526def threeSum(self, nums): result = [] nums.sort() for left in range(len(nums) - 2): # 右邊須留兩個空位給另兩個指標 if left &gt; 0 and nums[left] == nums[left - 1]: # 排除重複的 result，left 必須 &gt; 0 才會有前一個 continue # - 假如 nums[left] 是一樣的，最後找到的 result 也會是一樣的，所以要排除掉 mid = left + 1 right = len(nums) - 1 while mid &lt; right: # 設定有效範圍，在此範圍內尋找符合的 mid, right t_sum = nums[left] + nums[mid] + nums[right] if t_sum &lt; 0: mid += 1 # 此時必須讓 t_sum 變大，所以將 mid 往右移 elif t_sum &gt; 0: right -= 1 # 此時必須讓 t_sum 變小，所以將 right 往左移 else: result.append([nums[left], nums[mid], nums[right]]) while mid &lt; right and nums[mid] == nums[mid + 1]: # 跳過 mid 重複的部分 mid += 1 while mid &lt; right and nums[right] == nums[right - 1]: # 跳過 right 重複的部分 right -= 1 # 正常的移動 mid, right，尋找下一個符合的 result mid += 1 right -= 1 return result","link":"/2022/12/05/3-sum/"},{"title":"在 Mac 加入 ssh key 的步驟","text":"ssh-keygen -t ed25519 -C &quot;{你的 email}&quot; 預設路徑假如已有相同檔案，記得指定新的完整路徑 如檔名不用預設的，下面 id_ed25519 自行替換成自己的檔名 vi ~/.ssh/config 舉例：加上如下 1234Host GitHub HostName github.com IdentityFile ~/.ssh/id_ed25519 IdentitiesOnly yes ssh-add -K ~/.ssh/id_ed25519 pbcopy &lt; ~/.ssh/id_ed25519.pub 貼到所使用的服務網站的相對應設定頁面","link":"/2021/01/14/add-ssh-steps/"},{"title":"簡單統整 JWT 相對於傳統 Session 驗證的好處","text":"Server 不用存 Session 只有在 Client 拿新 JWT 時才需要跟 DB 溝通 Clent 拿的時機：JWT 到期或第一次拿 為何不需跟 DB 溝通？ 因為 JWT 裡已有所需資訊 但假如業務需求需要另外取敏感資訊的話還是需要碰 DB 參考","link":"/2021/01/14/jwt-digest/"},{"title":"PostgreSQL/MySQL local docker 開發的初始 setup","text":"container run 起來之後：PostgreSQL: docker exec -it {db-container-name} psql -U postgres 以預設 user postgres 連進 DB create user {username} with password '{password}'; create database {database_name} with owner {username}; 大功告成，可以用 \\l 列出所有 database &amp; \\du 列出所有 user 來確認 P.S. 假如一開始忘了指定 database owner 或想改變 owner: alter database {database_name} owner to {owner_name}; MySQL: (以 5.7 為例) 環境變數須設置 MYSQL_ROOT_PASSWORD docker exec -it {db-container-name} mysql -p 以預設 user root 連進去，輸入上面環境變數設置的密碼 create user '{username}'@'localhost' identified by '{password}'; Use localhost due to working on the machine with MySQL. create database {database_name}; 確認： show databases; SELECT user FROM mysql.user;","link":"/2020/02/07/postgresql-mysql-init-setup/"},{"title":"Search Insert Position note","text":"題目思路：最直覺是直接 iterate nums，不過題目指定要 O(log n)，所以用 binary search 才能達到 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: 設定 binary search 可繼續執行的條件 此時會想，要用 &lt; or &lt;= 呢？判斷依據為在迴圈裡變更完 left or right 之後，不能造成無窮迴圈 但此時還沒寫迴圈內容，所以可以先直觀的設定一個，譬如 &lt;，等寫完迴圈內容再來驗證是否適合 迴圈寫完後，回來 check while condition，看看 while 把 left &amp; right 收斂到最後幾個的時候，經過以下的操作會不會有無窮迴圈 121. left = mid + 12. right = mid 剩最後三個：此時 mid 會是中間那個，上面兩種操作都有助於收斂範圍 剩最後兩個：此時 mid == left，上面兩種操作一樣可以收斂範圍 剩最後一個：此時 left == mid == right，以目前的 while 條件設定，會因為不符而跳出，所以跳出迴圈後的情況就是這個 如果 while 條件為 left &lt;= right，則 right = mid 這個操作會造成無窮迴圈，因此不能設定為 &lt;= =&gt; 確認不會造成無窮迴圈，所以此 while 條件設定是正確的 Post processing: 跳出 while 後的情況為 left == right，此時再跟 target 比，決定答案為何 Python3 solution: 1234567891011def searchInsert(self, nums: List[int], target: int) -&gt; int: left, right = 0, len(nums) - 1 # 設定左右兩個指標作為可能答案範圍：[left, right] while left &lt; right: mid = (left + right) // 2 # Python3 不會有 integer overflow 的問題，所以可以直接 (left + right)，然後用 `//` 無條件捨去，避免小數 if nums[mid] == target: return mid if nums[mid] &lt; target: left = mid + 1 # 此時最小的可能答案為 `mid + 1` else: right = mid # 此時最大的可能答案為 `mid` return left + 1 if nums[left] &lt; target else left 更詳細解說可參考此篇文章","link":"/2022/12/08/search-insert-position/"},{"title":"用 pipenv 管理 requirements 搭配 docker-compose local 開發","text":"Local 開發是跑在 Docker 的虛擬環境裡，所以 Pipenv 產生的虛擬環境只是用來裝套件產生 Pipfile.lock 而已 用 pipenv 就不用自己寫 requirements.txt，不但可以自動安裝最新版的套件，而且可以很輕鬆的固定住對應 sub-packages 的版本 想一次更新所有套件也很容易 步驟：(以裝一個 package 為例) pip install --user pipenv 裝完後 command line 找不到 pipenv 的需把對應資料夾加入 PATH cd 到專案資料夾 pipenv install {target-package} 假如原本沒有 virtual environment，pipenv 會先幫你產生一個基於這個資料夾的 virtual environment 假如上層資料夾有 Pipfile，pipenv 會直接用那個 Pipfile 的 virtual environment，不會產生新的 這是因為 pipenv 的虛擬環境是 project base 的，所以你可以在一個 Django project 裡的任何一個資料夾執行 pipenv 都可以用到這個 project 的虛擬環境 而且正常情況下不會有 Django project 裡還有 Django project 的情況，所以不需要在上層已有 Pipfile 的情況下，又在目前資料夾產生 Pipfile 這邊不要指定版號，pipenv 就會安裝最新版 pipenv 會產生 Pipfile 和 Pipfile.lock, 後者有記錄這個 package 和 sub-packages 的固定版號 pipenv lock -r &gt; requirements.txt 將 Pipfile.lock 輸出為 requirements.txt 格式 接著就可以在 Dockerfile 裡直接用這個 requirements.txt 啦 如果要開新的 Django project: cd {你想要 project 資料夾放的位置} mkdir {project-name}; cd {project-name} pipenv install Django pipenv run django-admin startproject {project-name} . .: 要把 manage.py 放在當前資料夾 之後假如要把 requirements.txt 裡所有的 top-level 套件都更新的話: pipenv update 這個我自己沒試過，不過看文件應該是用這指令 重新輸出 requirements.txt 有看到另一種做法是可以不用自己產生 requirements.txt，直接在 Dockerfile 裡用 pipenv 動態生成 requirements.txt 來用，不過我自己還沒試過 Ref.","link":"/2020/02/06/pipenv-intro/"},{"title":"為什麼 Python dict 的 get item operation 時間複雜度為 O(1) ？","text":"如果去 google，大部分查到的都會說因為 Python 會把 key 經過 hash function 運算，得到一個 dict 真正內部在使用的 key，從而找到對應的 value。而一個好的 hash function 它的運算所需時間是不會隨著 n 增加而變大的，所以 dict 的 get item operation 時間複雜度為 O(1) 。 不過我的疑惑是，經過 hash function 運算得到 key 之後，由這個 key 去找到 value 的時間複雜度是 O(1) 嗎？除非這個也是 O(1) 才能說整個 get item operation 是 O(1) 。 後來再多翻了一些說明，終於看到一兩個回答可以解釋這個疑惑。可以想像成今天我們有一個 array，我們只要知道 index 就可以知道要去哪裡找到對應的 value ( 因此是 O(1) )，經由 hash function 算出來的 key 就好像 array 的 index 一樣，只要看到這個 key 就知道要去哪裡找對應的 value，不會受 n 大小的影響，所以是 O(1) 另一個比較生活化的例子：hash function 算出來的 key，就好像你在圖書館要找書時用的索引，看到索引你就會知道書在哪一區、哪個櫃子裡，即使你需要照著圖書館的索引指示找一下才能找到，但這個過程所花的時間，跟圖書館有多少書沒有關係。 References: https://qr.ae/pvMCpM https://qr.ae/pvMCIv","link":"/2022/07/25/why-dict-o1/"}],"tags":[{"name":"jwt","slug":"jwt","link":"/tags/jwt/"},{"name":"postgresql","slug":"postgresql","link":"/tags/postgresql/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"pipenv","slug":"pipenv","link":"/tags/pipenv/"},{"name":"django","slug":"django","link":"/tags/django/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"Authentication","slug":"Authentication","link":"/categories/Authentication/"},{"name":"Database","slug":"Database","link":"/categories/Database/"},{"name":"Package Management","slug":"Package-Management","link":"/categories/Package-Management/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"}]}