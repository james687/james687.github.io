<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>James&#39; Blog</title>
  
  <subtitle>程式隨筆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.jamesho.website/"/>
  <updated>2023-12-31T15:21:50.829Z</updated>
  <id>https://blog.jamesho.website/</id>
  
  <author>
    <name>James Ho</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redo Logs in Database Systems</title>
    <link href="https://blog.jamesho.website/database-redo-log/"/>
    <id>https://blog.jamesho.website/database-redo-log/</id>
    <published>2023-12-31T10:27:23.000Z</published>
    <updated>2023-12-31T15:21:50.829Z</updated>
    
    <content type="html"><![CDATA[<p>用 ChatGPT 查了下 redo log 是怎麼用在 database crash or power loss 後的 recovery 裡，這邊做個小筆記統整一下：</p><ul><li>進行交易時，會依序進行以下步驟：<ol><li>寫 redo log, 裡面記錄準備要做的改變，並記錄這個 transaction 的狀態為 <code>in progress</code></li><li>把 redo log 紀錄的那些改變實際寫入 database files</li><li>把 redo log 的 transaction 狀態改為 <code>committed</code></li><li>回傳 OK<a id="more"></a></li></ol></li><li>假如在 commit 前斷電，database server 重啟後，會執行以下 recovery process:<ol><li>Redo: 從 checkpoint 以後的 redo log 開始去 reapply 剩下的 redo logs 的 changes<ul><li>因為那些 uncommitted 的 redo logs 的 changes 很有可能已經有部分寫入到 database files(pages) 裡，所以會先檢查 pages 裡的 LSN (Log Sequence Number), 假如 page 裡的 LSN &gt;= redo log 的，代表該 redo log 的 change 已經寫入了，就不用再 apply (LSN 是有順序性的)</li></ul></li><li>Undo: 把 reapply 的那些 redo logs 裡，transaction state 為 uncommitted 的進行 rollback operation</li></ol><ul><li>Note: 為何不是單純 ignore 那些 uncommitted 的 redo logs 就好？<ul><li>因為那些 redo logs 可能已經有 partially write to database files 了，所以為了確保 consistency, 必須要先 redo 再 undo</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用 ChatGPT 查了下 redo log 是怎麼用在 database crash or power loss 後的 recovery 裡，這邊做個小筆記統整一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;進行交易時，會依序進行以下步驟：&lt;ol&gt;
&lt;li&gt;寫 redo log, 裡面記錄準備要做的改變，並記錄這個 transaction 的狀態為 &lt;code&gt;in progress&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;把 redo log 紀錄的那些改變實際寫入 database files&lt;/li&gt;
&lt;li&gt;把 redo log 的 transaction 狀態改為 &lt;code&gt;committed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;回傳 OK
    
    </summary>
    
    
      <category term="Deep Dive" scheme="https://blog.jamesho.website/categories/Deep-Dive/"/>
    
    
      <category term="database" scheme="https://blog.jamesho.website/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>133. Clone Graph</title>
    <link href="https://blog.jamesho.website/clone-graph/"/>
    <id>https://blog.jamesho.website/clone-graph/</id>
    <published>2023-11-26T02:27:23.000Z</published>
    <updated>2023-11-26T03:09:57.530Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/clone-graph/description/">題目</a><br>思路：</p><ol><li>可以找到最小可重複動作嗎？<ul><li>題目的 method 要傳入 first node, 回傳它的 clone</li><li>最小可重複動作可設定為：給定一個 node, 回傳 its clone</li></ul></li><li>DFS: 先寫 recursive case</li><li>Base case: method 收到已 clone 過的 node<ul><li>Use a dict to record nodes been cloned.</li></ul></li><li>須注意傳入 cloneGraph 的 node 有可能是 None<a id="more"></a></li></ol><figure class="highlight python"><figcaption><span>Python3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val = 0, neighbors = None):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors if neighbors is not None else []</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: Optional[<span class="string">'Node'</span>])</span> -&gt; Optional['Node']:</span></span><br><span class="line">        old_new_map = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clone_node</span><span class="params">(node)</span>:</span></span><br><span class="line">            <span class="comment"># Base case</span></span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">in</span> old_new_map:</span><br><span class="line">                <span class="keyword">return</span> old_new_map[node]</span><br><span class="line">        </span><br><span class="line">            <span class="comment"># Recursive case</span></span><br><span class="line">            clone = Node(node.val)</span><br><span class="line">            old_new_map[node] = clone</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                clone.neighbors.append(clone_node(neighbor))        </span><br><span class="line">            <span class="keyword">return</span> clone</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> node <span class="keyword">and</span> clone_node(node)</span><br></pre></td></tr></table></figure><h3 id="How-to-do-it-with-BFS"><a href="#How-to-do-it-with-BFS" class="headerlink" title="How to do it with BFS?"></a>How to do it with BFS?</h3><p>思路</p><ol><li>一開始的直覺想法是就照 DFS 的套路，只是改成 recursive case 在迴圈裡做，也就是說把要執行最小可重複動作的 node 放入 stack 讓他在之後的迴圈去做 recursive case<ul><li>上面的 recursive case: clone 自己，也 clone 自己的所有 neighbors 並加到我的 clone 的 neighbors</li></ul></li><li>發現問題：那些 neighbors 繼續丟進 stack 想重複一樣的動作時，發現會 clone 兩次，表示這個動作拆的不好</li><li>修改最小可重複動作：<strong>我先 clone 好自己，最小可重複動作改成 clone 我的 neighbors 並加入我 clone 的 neighbors</strong>，這樣就不會 clone 兩次了，所有加入 stack 的 node 都是已經 clone 過的</li><li>clone 前先檢查 base case：假如這個 neighbor 有在 <code>old_to_new</code> 裡，代表他已經有被 clone 過了，而且也有被加入過 stack，所以不用再 clone &amp; add to stack，但還是要把他的 clone add to neighbors，因為一個點可能同時是好幾個點的鄰居，所以當然有可能被加好幾次鄰居</li></ol><figure class="highlight python"><figcaption><span>Python3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: Optional[<span class="string">'Node'</span>])</span> -&gt; Optional['Node']:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    stack = [node]</span><br><span class="line">    old_to_new = &#123;node: Node(node.val)&#125;</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        n = stack.pop()</span><br><span class="line">        <span class="keyword">for</span> neighbor <span class="keyword">in</span> n.neighbors:</span><br><span class="line">            <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> old_to_new:</span><br><span class="line">                n_clone = Node(neighbor.val)</span><br><span class="line">                old_to_new[neighbor] = n_clone</span><br><span class="line">                stack.append(neighbor)</span><br><span class="line">            old_to_new[n].neighbors.append(old_to_new[neighbor])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> old_to_new[node]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/clone-graph/description/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以找到最小可重複動作嗎？&lt;ul&gt;
&lt;li&gt;題目的 method 要傳入 first node, 回傳它的 clone&lt;/li&gt;
&lt;li&gt;最小可重複動作可設定為：給定一個 node, 回傳 its clone&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DFS: 先寫 recursive case&lt;/li&gt;
&lt;li&gt;Base case: method 收到已 clone 過的 node&lt;ul&gt;
&lt;li&gt;Use a dict to record nodes been cloned.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;須注意傳入 cloneGraph 的 node 有可能是 None
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="breadth-first search" scheme="https://blog.jamesho.website/tags/breadth-first-search/"/>
    
      <category term="graph" scheme="https://blog.jamesho.website/tags/graph/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance</title>
    <link href="https://blog.jamesho.website/smallest-number-neighbors/"/>
    <id>https://blog.jamesho.website/smallest-number-neighbors/</id>
    <published>2023-11-25T06:36:07.000Z</published>
    <updated>2023-11-25T08:00:56.699Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/">題目</a><br>思路：</p><ul><li>要找的點是<strong>可到達的點</strong>的距離在 threshold 裡的那些點，所以要找的是最短距離，因為只要最短距離可以在 threshold 內，那它就是可到達的點</li><li>用 Floyd-Warshall’s algorithm 找到所有點之間的最小距離<ul><li><code>k</code> 是 <code>i</code> 到 <code>j</code> 之間的任意點。比較 <code>i</code> -&gt; <code>j</code> 經過所有 <code>k</code> 的距離，最小的即為 <code>i</code> -&gt; <code>j</code> 的最短距離。</li><li>Question:<br>if the path is <code>i -&gt; 2 -&gt; 1 -&gt; j</code> and the iteration consider <code>k == 1</code> first. But the <code>dist[i][1]</code> not yet populated and still have value of <code>float(&#39;inf&#39;)</code>. It will have the actual value until <code>k == 2</code>. <a id="more"></a><ul><li>Answer from ChatGPT: <ul><li>You’ve identified a key aspect of the Floyd-Warshall algorithm’s iterative process. The algorithm relies on the gradual building of shortest paths through each possible intermediate vertex, and the order of considering vertices (the k values) doesn’t prevent it from eventually finding the shortest paths.</li><li>In your example, even if k == 1 is considered first and the direct path i -&gt; 1 or 1 -&gt; j isn’t the shortest, the algorithm might not immediately find the shortest path i -&gt; 2 -&gt; 1 -&gt; j. However, when k == 2 is later considered, the algorithm will then take into account paths through 2, updating the shortest path calculations accordingly.</li><li>The crux of the Floyd-Warshall algorithm is that by the time all vertices have been iteratively considered as potential intermediate steps, it will have computed the shortest paths between all pairs of vertices, considering all possible intermediate vertices and paths.</li></ul></li></ul></li></ul></li><li>比較每個點在 threshold 內可達的點的個數，找出最小的＆有最大 number 的點</li></ul><figure class="highlight python"><figcaption><span>Python3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findTheCity</span><span class="params">(self, n: int, edges: List[List[int]], distanceThreshold: int)</span> -&gt; int:</span></span><br><span class="line">    dist = [[float(<span class="string">'inf'</span>)] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Init</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        dist[i][i] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j, w <span class="keyword">in</span> edges:</span><br><span class="line">        dist[i][j] = dist[j][i] = w</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Find the shortest distance.</span></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the smallest count.</span></span><br><span class="line">    min_count = float(<span class="string">'inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        count = sum(dist[i][j] &lt;= distanceThreshold <span class="keyword">for</span> j <span class="keyword">in</span> range(n))</span><br><span class="line">        <span class="keyword">if</span> count &lt;= min_count:</span><br><span class="line">            min_count = count</span><br><span class="line">            r = i</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure><ul><li>要注意一下 <code>dist[i][j] = dist[j][i] = w</code> 蠻容易漏掉中間那個 <code>dist[j][i]</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/description/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;要找的點是&lt;strong&gt;可到達的點&lt;/strong&gt;的距離在 threshold 裡的那些點，所以要找的是最短距離，因為只要最短距離可以在 threshold 內，那它就是可到達的點&lt;/li&gt;
&lt;li&gt;用 Floyd-Warshall’s algorithm 找到所有點之間的最小距離&lt;ul&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 是 &lt;code&gt;i&lt;/code&gt; 到 &lt;code&gt;j&lt;/code&gt; 之間的任意點。比較 &lt;code&gt;i&lt;/code&gt; -&amp;gt; &lt;code&gt;j&lt;/code&gt; 經過所有 &lt;code&gt;k&lt;/code&gt; 的距離，最小的即為 &lt;code&gt;i&lt;/code&gt; -&amp;gt; &lt;code&gt;j&lt;/code&gt; 的最短距離。&lt;/li&gt;
&lt;li&gt;Question:&lt;br&gt;if the path is &lt;code&gt;i -&amp;gt; 2 -&amp;gt; 1 -&amp;gt; j&lt;/code&gt; and the iteration consider &lt;code&gt;k == 1&lt;/code&gt; first. But the &lt;code&gt;dist[i][1]&lt;/code&gt; not yet populated and still have value of &lt;code&gt;float(&amp;#39;inf&amp;#39;)&lt;/code&gt;. It will have the actual value until &lt;code&gt;k == 2&lt;/code&gt;.
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="graph" scheme="https://blog.jamesho.website/tags/graph/"/>
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
      <category term="dynamic programming" scheme="https://blog.jamesho.website/tags/dynamic-programming/"/>
    
      <category term="shortest path" scheme="https://blog.jamesho.website/tags/shortest-path/"/>
    
  </entry>
  
  <entry>
    <title>1046. Last Stone Weight</title>
    <link href="https://blog.jamesho.website/last-stone-weight/"/>
    <id>https://blog.jamesho.website/last-stone-weight/</id>
    <published>2023-04-20T09:14:40.000Z</published>
    <updated>2023-11-16T02:13:10.424Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/last-stone-weight/">題目</a><br>最直覺的作法就是先排序，取出最重的兩個撞擊後，把剩下的放回去，然後重複以上步驟：</p><figure class="highlight python"><figcaption><span>Intuitive Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span><span class="params">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">while</span> len(stones) &gt; <span class="number">1</span>:</span><br><span class="line">        stones.sort()</span><br><span class="line">        s1 = stones.pop()</span><br><span class="line">        s2 = stones.pop()</span><br><span class="line">        <span class="keyword">if</span> s1 != s2:</span><br><span class="line">            stones.append(s1 - s2)</span><br><span class="line">    <span class="keyword">return</span> stones[<span class="number">0</span>] <span class="keyword">if</span> stones <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>但這樣的時間複雜度為 O(n^2 * log n)，太大了，有沒有其他方法？<a id="more"></a></p><p>思路：</p><ol><li>上面的時間複雜度會大，主因是每次都要花 O(n*log n) 重新排序，有沒有資料結構可以在新增資料的時候小成本的維護大小順序？</li><li>答案是 heap，而 Python 有 <code>heapq</code> 這個 implement heap 的 module 可用</li></ol><figure class="highlight python"><figcaption><span>Improved Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lastStoneWeight</span><span class="params">(self, stones: List[int])</span> -&gt; int:</span></span><br><span class="line">    stones = [-stone <span class="keyword">for</span> stone <span class="keyword">in</span> stones]  <span class="comment"># 將 stones 轉換為負數，使其成為最大堆（Max Heap）</span></span><br><span class="line">    heapq.heapify(stones)  <span class="comment"># In-place transform the list to min heap.</span></span><br><span class="line">    <span class="keyword">while</span> len(stones) &gt; <span class="number">1</span>:</span><br><span class="line">        s1 = heapq.heappop(stones)</span><br><span class="line">        s2 = heapq.heappop(stones)</span><br><span class="line">        <span class="keyword">if</span> s1 != s2:</span><br><span class="line">            heapq.heappush(stones, s1 - s2)  <span class="comment"># 第二個參數為小的減大的，因為要放負數進去</span></span><br><span class="line">    <span class="keyword">return</span> -stones[<span class="number">0</span>] <span class="keyword">if</span> stones <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p><strong>時間複雜度分析：</strong><br>迴圈外：line 5, 6 都是 O(n)<br>迴圈內：因為 <code>heapq.heappop</code> 和 <code>heapq.heappush</code> 的時間複雜度為 O(log n)，所以迴圈內的複雜度為 O(log n)<br>迴圈條件：<code>len(stones)</code> 時間複雜度為 O(1)<br>迴圈執行次數：最差的情況為每次都 push 東西進去，也就是整體上每次都 pop 一個出來，會執行 <code>n - 1</code> 次<br>=&gt; 綜合以上，時間複雜度為 O(n log n)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/last-stone-weight/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;最直覺的作法就是先排序，取出最重的兩個撞擊後，把剩下的放回去，然後重複以上步驟：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Intuitive Python 3 solution&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lastStoneWeight&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, stones: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; len(stones) &amp;gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        stones.sort()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s1 = stones.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        s2 = stones.pop()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; s1 != s2:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            stones.append(s1 - s2)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; stones[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; stones &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;但這樣的時間複雜度為 O(n^2 * log n)，太大了，有沒有其他方法？
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
      <category term="heap" scheme="https://blog.jamesho.website/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>844. Backspace String Compare</title>
    <link href="https://blog.jamesho.website/backspace-string-compare/"/>
    <id>https://blog.jamesho.website/backspace-string-compare/</id>
    <published>2023-04-20T05:24:05.000Z</published>
    <updated>2023-04-22T10:50:31.688Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/backspace-string-compare/">題目</a><br>這邊記錄自己答案的演變和檢討，有需要的也可以直接跳到<a href="/backspace-string-compare/#final-answer">最後的 O(1) space complexity 解答</a></p><p>一開始的思路：用遞增的 index 同時 go through 這兩個字串，按照裡面的 backspace hint build 出兩個新的字串再來看看是否相等<a id="more"></a></p><figure class="highlight python"><figcaption><span>Python 3 solution at first</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    new_t, new_s = <span class="string">''</span>, <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(max(len(s), len(t))):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            sc = s[i]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> sc == <span class="string">'#'</span> <span class="keyword">and</span> new_s:</span><br><span class="line">                new_s = new_s[:len(new_s) - <span class="number">1</span>]  <span class="comment"># Remove new_s's last character</span></span><br><span class="line">            <span class="keyword">elif</span> sc != <span class="string">'#'</span>:</span><br><span class="line">                new_s += sc</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            tc = t[i]</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> tc == <span class="string">'#'</span> <span class="keyword">and</span> new_t:</span><br><span class="line">                new_t = new_t[:len(new_t) - <span class="number">1</span>]  <span class="comment"># Remove new_t's last character</span></span><br><span class="line">            <span class="keyword">elif</span> tc != <span class="string">'#'</span>:</span><br><span class="line">                new_t += tc</span><br><span class="line">    <span class="keyword">return</span> new_t == new_s</span><br></pre></td></tr></table></figure><p>缺點：每次遇到 <code>#</code> 就會有個 O(k) 的操作<br>改進：假如用 list 來放字元，<code>pop()</code> 只有 O(1)，再用 O(m) 的 <code>str.join</code> 合成最終的字串<br>(1 &lt;= <code>k</code> &lt; n, 1 &lt;= <code>m</code> &lt;= n, n 為字串長度)</p><figure class="highlight python"><figcaption><span>Improved Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(s)</span>:</span></span><br><span class="line">        arr = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c != <span class="string">'#'</span>:</span><br><span class="line">                arr.append(c)</span><br><span class="line">            <span class="keyword">elif</span> arr:</span><br><span class="line">                arr.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(arr)</span><br><span class="line">    <span class="keyword">return</span> build(s) == build(t)</span><br></pre></td></tr></table></figure><p>時間和空間複雜度都是 O(n)<br><a name="final-answer"></a></p><h3 id="題目的-Follow-up-Can-you-solve-it-in-O-n-time-and-O-1-space"><a href="#題目的-Follow-up-Can-you-solve-it-in-O-n-time-and-O-1-space" class="headerlink" title="題目的 Follow up: Can you solve it in O(n) time and O(1) space?"></a>題目的 Follow up: Can you solve it in O(n) time and O(1) space?</h3><p>思路</p><ol><li>不能用額外的 array 來儲存新的字串，那就只能使用 pointer 來 go through 字串，一個個字母依序比較</li><li>假如從頭開始 go through 有點困難，因為你不知道當前的字母會不會在之後被刪除，那從後往前可以嗎？</li><li>從後往前的話可以。因為只要遇到當前字母之前都沒有 <code>#</code>，該字母就一定會在最終字串裡，而我們一樣可以比較每個字母來判斷兩個字串最終是否相等，當遇到 <code>#</code> 時也可以很容易地跳過</li><li>必須要有一個 function for <code>s</code> 和 <code>t</code>，讓我們可以傳入字串和 index，告訴我們：<ul><li>從那個 index 開始往前的話，下一個合法字母是什麼</li><li>下一個 index 從哪邊開始</li></ul></li></ol><figure class="highlight python"><figcaption><span>Final Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backspaceCompare</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_next_char</span><span class="params">(string: str, index: int)</span> -&gt; tuple:</span></span><br><span class="line">        <span class="string">"""Helper function to get the next valid character and the next index in the string"""</span></span><br><span class="line">        skip = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> index &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> string[index] == <span class="string">'#'</span>:</span><br><span class="line">                skip += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> skip &gt; <span class="number">0</span>:</span><br><span class="line">                skip -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> string[index], index - <span class="number">1</span></span><br><span class="line">            index -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>, <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    i = len(s) - <span class="number">1</span></span><br><span class="line">    j = len(t) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span> <span class="keyword">or</span> j &gt;= <span class="number">0</span>:</span><br><span class="line">        char_s, i = get_next_char(s, i)</span><br><span class="line">        char_t, j = get_next_char(t, j)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> char_s != char_t:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/backspace-string-compare/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;這邊記錄自己答案的演變和檢討，有需要的也可以直接跳到&lt;a href=&quot;/backspace-string-compare/#final-answer&quot;&gt;最後的 O(1) space complexity 解答&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一開始的思路：用遞增的 index 同時 go through 這兩個字串，按照裡面的 backspace hint build 出兩個新的字串再來看看是否相等
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="two pointers" scheme="https://blog.jamesho.website/tags/two-pointers/"/>
    
      <category term="stack" scheme="https://blog.jamesho.website/tags/stack/"/>
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
      <category term="simulation" scheme="https://blog.jamesho.website/tags/simulation/"/>
    
  </entry>
  
  <entry>
    <title>438. Find All Anagrams in a String</title>
    <link href="https://blog.jamesho.website/find-all-anagrams-in-a-string/"/>
    <id>https://blog.jamesho.website/find-all-anagrams-in-a-string/</id>
    <published>2023-04-19T15:42:40.000Z</published>
    <updated>2023-04-22T10:50:35.371Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">題目</a><br>思路：怎麼判斷兩個字串是不是 anagram?</p><ul><li>可以把兩個字串都做排序，再看看是否相等，但這樣每次都要多花 O(n) 時間</li><li>可以計算每個字母出現的頻率，再看看兩個字串的計算結果是否相等。雖然單獨算也是要 O(n)，但假如搭配 sliding window 移動的時候一個個字母加入計算，就不會有額外的時間複雜度<a id="more"></a></li></ul><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">    p_len = len(p)</span><br><span class="line">    <span class="keyword">if</span> p_len &gt; len(s):</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">    target_freq = defaultdict(int)  <span class="comment"># Character frequency of possible anagram.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Character frequency of `p`.</span></span><br><span class="line">    p_freq = defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> p:</span><br><span class="line">        p_freq[c] += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="comment"># 把超過 p 長度的部分扣掉，維持 window 寬 (想像 window 往右，這邊移掉左邊一格)</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= p_len:</span><br><span class="line">            target_freq[s[i - p_len]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> target_freq[s[i - p_len]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> target_freq[s[i - p_len]]  <span class="comment"># 個數減為 0 的話記得要把整個 key 拿掉，不然不可能會跟 `p_freq` 相等</span></span><br><span class="line"></span><br><span class="line">        target_freq[s[i]] += <span class="number">1</span>  <span class="comment"># Frequency 計算：加入當前字元 (`i` 是 sliding window 最右邊的 index)</span></span><br><span class="line">        <span class="keyword">if</span> target_freq == p_freq:</span><br><span class="line">            res.append(i - p_len + <span class="number">1</span>)  <span class="comment"># 加入 sliding window 起始點到答案中</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>P.S.<br>字母頻率計算也可以用 <code>collections.Counter</code>，跟 <code>defaultdict(int)</code> 使用方法一樣，範例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = collections.Counter(<span class="string">'geeeg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">'e'</span>: <span class="number">3</span>, <span class="string">'g'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c[<span class="string">'t'</span>] += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line">Counter(&#123;<span class="string">'e'</span>: <span class="number">3</span>, <span class="string">'g'</span>: <span class="number">2</span>, <span class="string">'t'</span>: <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li><code>collections.Counter</code> 建構子可以傳入任何 iterable</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/find-all-anagrams-in-a-string/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路：怎麼判斷兩個字串是不是 anagram?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以把兩個字串都做排序，再看看是否相等，但這樣每次都要多花 O(n) 時間&lt;/li&gt;
&lt;li&gt;可以計算每個字母出現的頻率，再看看兩個字串的計算結果是否相等。雖然單獨算也是要 O(n)，但假如搭配 sliding window 移動的時候一個個字母加入計算，就不會有額外的時間複雜度
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
      <category term="sliding window" scheme="https://blog.jamesho.website/tags/sliding-window/"/>
    
  </entry>
  
  <entry>
    <title>733. Flood Fill</title>
    <link href="https://blog.jamesho.website/flood-fill/"/>
    <id>https://blog.jamesho.website/flood-fill/</id>
    <published>2023-04-19T07:27:31.000Z</published>
    <updated>2023-04-22T11:01:43.991Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/flood-fill/">題目</a><br>紀錄一下一開始的思路，檢討錯誤，再整理<a href="/flood-fill/#answer">最後的答案</a>。一開始的想法：</p><ol><li>這應該可以分解成最小可重複動作，用遞迴解看看</li><li>覺得可以用原本的 method 當遞迴函式，把 <code>image</code>, <code>color</code> 照樣傳入，<code>sr</code>, <code>sc</code> 為該點的座標</li><li><a name="minimum-repeatable"></a>最小可重複動作：從當下這點擴散到周圍四個點<a id="more"></a> </li></ol><figure class="highlight python"><figcaption><span>Wrong solution at first</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floodFill</span><span class="params">(self, image: List[List[int]], sr: int, sc: int, color: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    self_color = image[sr][sc]</span><br><span class="line">    m = len(image)</span><br><span class="line">    n = len(image[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Base case</span></span><br><span class="line">    <span class="keyword">if</span> sr &lt; <span class="number">0</span> <span class="keyword">or</span> sr &gt;= m <span class="keyword">or</span> sc &lt; <span class="number">0</span> <span class="keyword">or</span> sc &gt;= n <span class="keyword">or</span> color == self_color:</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line">    l_color = image[sr - <span class="number">1</span>][sc]</span><br><span class="line">    r_color = image[sr + <span class="number">1</span>][sc]</span><br><span class="line">    u_color = image[sr][sc + <span class="number">1</span>]</span><br><span class="line">    d_color = image[sr][sc - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> self_color <span class="keyword">not</span> <span class="keyword">in</span> (l_color, r_color, u_color, d_color):</span><br><span class="line">        image[sr][sc] = color</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Recursive case</span></span><br><span class="line">    <span class="keyword">if</span> l_color == self_color:</span><br><span class="line">        image[sr][sc] = color</span><br><span class="line">        self.floodFill(image, sr - <span class="number">1</span>, sc, color)</span><br><span class="line">    <span class="keyword">if</span> r_color == self_color:</span><br><span class="line">        image[sr][sc] = color</span><br><span class="line">        self.floodFill(image, sr + <span class="number">1</span>, sc, color)</span><br><span class="line">    <span class="keyword">if</span> u_color == self_color:</span><br><span class="line">        image[sr][sc] = color</span><br><span class="line">        self.floodFill(image, sr, sc + <span class="number">1</span>, color)</span><br><span class="line">    <span class="keyword">if</span> d_color == self_color:</span><br><span class="line">        image[sr][sc] = color</span><br><span class="line">        self.floodFill(image, sr, sc - <span class="number">1</span>, color)</span><br></pre></td></tr></table></figure><p>結果發生 index out of bound error (舉例，當 <code>sr == m - 1</code> 時，再用 <code>image[sr + 1]</code> 就會遇到)</p><p><strong>檢討：</strong></p><ul><li><p>會用到 <code>image[sr + 1]</code> 是為了要取到鄰近的顏色來判斷是不是應該去 flood，而那些判斷只是為了決定是否要執行遞迴呼叫 =&gt; <strong>判斷是否該執行遞迴呼叫應該直接在該遞迴函式的 base case 裡做判斷</strong></p><ul><li>不去取顏色自然就不會遇到這個錯誤</li><li>改成在 base case 的判斷 <code>我這個點的顏色是不是跟起點的顏色一樣</code></li></ul></li><li><p>中間這段沒必要，此情境已包含於那些遞迴呼叫裡</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> self_color <span class="keyword">not</span> <span class="keyword">in</span> (l_color, r_color, u_color, d_color):</span><br><span class="line">    image[sr][sc] = color</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure></li><li><p>可以把題目的 <code>color</code> 參數名改為 <code>new_color</code>，增加可讀性</p></li><li><p>可以另外用一個 inner function 來當遞迴函式，因為實際會傳不一樣參數的只有座標，另兩個其實可以不用傳入，另外用一個 inner function 可以讓程式更簡潔易讀</p></li></ul><p><a name="answer"></a>根據上面的檢討，修改後的答案如下：</p><figure class="highlight python"><figcaption><span>Python 3 solution - DFS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floodFill</span><span class="params">(self, image: List[List[int]], sr: int, sc: int, new_color: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    ori_color = image[sr][sc]</span><br><span class="line">    m = len(image)</span><br><span class="line">    n = len(image[<span class="number">0</span>])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flood</span><span class="params">(row, col)</span>:</span></span><br><span class="line">        <span class="comment"># Base case</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= m <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> image[row][col] != ori_color <span class="keyword">or</span> image[row][col] == new_color:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        image[row][col] = new_color</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Recursive case</span></span><br><span class="line">        flood(row + <span class="number">1</span>, col)</span><br><span class="line">        flood(row - <span class="number">1</span>, col)</span><br><span class="line">        flood(row, col + <span class="number">1</span>)</span><br><span class="line">        flood(row, col - <span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">    flood(sr, sc)</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure><ul><li>記得要先把起點的顏色記到變數裡，而不是在 base case 的判斷裡直接用 <code>image[sr][sc]</code> 來取，因為起點的顏色在經過第一次 <code>flood</code> 呼叫後就變了</li><li>base case 裡這個判斷 <code>image[row][col] == new_color</code>，它主要是在看假如這個點已經 flood 過了，就直接 <code>return</code>，但還有一種情形：沒 flood 過，這個點本來就是 new_color。假如是這種情況，又再細分為以下兩個情形：<ul><li><code>ori_color != new_color</code>: 假如是這種情況，在前面的 <code>image[row][col] != ori_color</code> 就會滿足而 <code>return</code> 了</li><li><code>ori_color == new_color</code>: 此時也應該 <code>return</code>，因為假如是這樣，那本來整個 image 就不會因為 <code>floodFill</code> 而變</li></ul></li></ul><h3 id="上面的遞迴解法是屬於-DFS-Depth-First-Search-，假如用-BFS-Breadth-First-Search-來解呢？"><a href="#上面的遞迴解法是屬於-DFS-Depth-First-Search-，假如用-BFS-Breadth-First-Search-來解呢？" class="headerlink" title="上面的遞迴解法是屬於 DFS (Depth-First Search)，假如用 BFS (Breadth-First Search) 來解呢？"></a>上面的遞迴解法是屬於 DFS (Depth-First Search)，假如用 BFS (Breadth-First Search) 來解呢？</h3><p>假如已經用 DFS 解過了，那 BFS 應該可以依循同樣的思考邏輯很快寫出來，只需調整一下架構：</p><ol><li>先過濾掉不需繼續做的情況</li><li>準備一個 stack，放入起始情況的條件</li><li>只要 stack 裡有東西，就做<a href="#minimum-repeatable">最小可重複動作</a></li><li><code>終止條件</code>對應到上面的 base case，<code>要繼續檢查的部分</code>對應到上面的 recursive case</li></ol><figure class="highlight python"><figcaption><span>Python 3 solution - BFS</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floodFill</span><span class="params">(self, image: List[List[int]], sr: int, sc: int, new_color: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    ori_color = image[sr][sc]</span><br><span class="line">    <span class="keyword">if</span> new_color == ori_color:</span><br><span class="line">        <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    stack = [(sr, sc)]</span><br><span class="line">    m = len(image)</span><br><span class="line">    n = len(image[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        row, col = stack.pop()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 終止條件</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt;= m <span class="keyword">or</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt;= n:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> image[row][col] != ori_color <span class="keyword">or</span> image[row][col] == new_color:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        </span><br><span class="line">        image[row][col] = new_color</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 要繼續檢查的部分</span></span><br><span class="line">        stack.extend([(row + <span class="number">1</span>, col), (row - <span class="number">1</span>, col), (row, col + <span class="number">1</span>), (row, col - <span class="number">1</span>)])</span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/flood-fill/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;紀錄一下一開始的思路，檢討錯誤，再整理&lt;a href=&quot;/flood-fill/#answer&quot;&gt;最後的答案&lt;/a&gt;。一開始的想法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;這應該可以分解成最小可重複動作，用遞迴解看看&lt;/li&gt;
&lt;li&gt;覺得可以用原本的 method 當遞迴函式，把 &lt;code&gt;image&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt; 照樣傳入，&lt;code&gt;sr&lt;/code&gt;, &lt;code&gt;sc&lt;/code&gt; 為該點的座標&lt;/li&gt;
&lt;li&gt;&lt;a name=&quot;minimum-repeatable&quot;&gt;&lt;/a&gt;最小可重複動作：從當下這點擴散到周圍四個點
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="breadth-first search" scheme="https://blog.jamesho.website/tags/breadth-first-search/"/>
    
      <category term="matrix" scheme="https://blog.jamesho.website/tags/matrix/"/>
    
  </entry>
  
  <entry>
    <title>589. N-ary Tree Preorder Traversal</title>
    <link href="https://blog.jamesho.website/n-ary-tree-preorder-traversal/"/>
    <id>https://blog.jamesho.website/n-ary-tree-preorder-traversal/</id>
    <published>2023-04-18T05:59:22.000Z</published>
    <updated>2023-04-22T10:50:40.792Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">題目</a><br>思路</p><ol><li>樹的問題會先從遞迴來想比較直觀，首先找出最小可重複動作來作為 recursive case</li><li>先假設我們可以用題目給的 method 直接當作遞迴的函式，也就是說我們遞迴函式的回傳，是 preorder 排序的 node values</li><li>最小可重複動作：對於我這個 node 來說，回傳 preordered values</li></ol><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = [root.val]</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children <span class="keyword">or</span> []:</span><br><span class="line">        result.extend(self.preorder(child))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="假如用迭代的方式來解呢？"><a href="#假如用迭代的方式來解呢？" class="headerlink" title="假如用迭代的方式來解呢？"></a>假如用迭代的方式來解呢？</h3><ol><li>用 stack, 把要處理的放入，迴圈內每次都拿一個出來，做 <code>最小可重複動作</code>，做到 stack 沒東西為止</li><li>注意在放入 <code>child</code> 的時候這邊是用 reverse order 來放，因為我到時候拿出來的時候想用 <code>.pop()</code>(O(1) 時間複雜度) 而不是 <code>.pop(0)</code>(O(n) 時間複雜度)</li></ol><figure class="highlight python"><figcaption><span>Python 3 iterative solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = [root]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.children:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> reversed(node.children):</span><br><span class="line">            stack.append(child)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/n-ary-tree-preorder-traversal/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;樹的問題會先從遞迴來想比較直觀，首先找出最小可重複動作來作為 recursive case&lt;/li&gt;
&lt;li&gt;先假設我們可以用題目給的 method 直接當作遞迴的函式，也就是說我們遞迴函式的回傳，是 preorder 排序的 node values&lt;/li&gt;
&lt;li&gt;最小可重複動作：對於我這個 node 來說，回傳 preordered values&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Python 3 solution&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: &lt;span class=&quot;string&quot;&gt;&#39;Node&#39;&lt;/span&gt;)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; root:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = [root.val]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; child &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root.children &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; []:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.extend(self.preorder(child))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="stack" scheme="https://blog.jamesho.website/tags/stack/"/>
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>[Python] list 用 `.extend()` 與 `+=` 的差別</title>
    <link href="https://blog.jamesho.website/diff-between-extend-and-plusequal/"/>
    <id>https://blog.jamesho.website/diff-between-extend-and-plusequal/</id>
    <published>2023-04-17T07:19:11.000Z</published>
    <updated>2023-04-17T07:45:25.668Z</updated>
    
    <content type="html"><![CDATA[<p>譬如有兩個 list <code>a</code> 和 <code>b</code>，使用 <code>a.extend(b)</code> 和 <code>a += b</code> 有什麼相同或不同？有沒有什麼 general 的 best practice for using one rather than the other?</p><p>其實在這個情境下，這兩個用法幾乎一樣。它們都會直接 in-place 的修改 <code>a</code>，把 <code>b</code> 裡面的元素加到 <code>a</code> 的後面</p><ul><li><code>+=</code> 會呼叫 list 的 <code>.__iadd__()</code> 來做 in-place 的修改<ul><li>所以在這個情境下，<code>b</code> 可以是任何 iterable，譬如 <code>[] += {}</code> 會得到 <code>[]</code></li><li>假如用 <code>+=</code> 的是 immutable 的 type，Python 發現沒有 <code>.__iadd__()</code>，接著就會呼叫它的 <code>.__add__()</code>，此情況下 <code>a += b</code> 等同於 <code>a = a + b</code></li></ul></li></ul><p>以下列出少數有差別的地方：<a id="more"></a></p><ul><li><code>+=</code> 不能用在 tuple 裡的 list，但 <code>.extend()</code> 可以<ul><li>雖然說 <code>+=</code> 所呼叫的 <code>.__iadd__()</code> 是 in-place 修改，做完後 <code>a</code> 的 reference 還是會一樣，但過程中還是會以某種方式動到 reference，只是最後會有個 reassign 給自己的動作<a href="#anno1">[註1]</a>，所以會有一樣的 reference</li></ul></li><li><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend/24261311#24261311"><code>+=</code> 不能用在 non-local variable，但 <code>.extend()</code> 可以</a></li><li><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend/37762884#37762884"><code>+=</code> 不能 chain function call, 但 <code>.extend()</code> 可以</a></li><li>兩者速度依不同情況稍有差異<ul><li>可參考<a href="#anno1">註1</a>這個 comment 下兩個接續的 comments: <a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754463_28119966">comment 1</a>, <a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754732_28119966">comment 2</a></li></ul></li></ul><p><strong>結論</strong><br>可以都用 <code>.extend()</code> 就好，consistency 也是一個重點。對於有差別的部分，一般情況下速度的差異可以忽略，其他的差別都是 <code>.extend()</code> 比較好，而且它在語意上的描述也也更貼切。</p><p><em>參考資料：</em></p><ul><li><p><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend">Concatenating two lists - difference between ‘+=’ and extend()</a></p></li><li><p><a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend">What is the difference between Python’s list methods append and extend?</a></p><ul><li><p><a name="anno1"></a><a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754266_28119966">註1</a>:</p><blockquote><p><code>l1 += l2</code> and <code>l1.extend(l2)</code> ultimately execute the same code (the <code>list_extend</code> function in <code>listobject.c</code>). The only differences are: 1. <code>+=</code> reassigns <code>l1</code> (to itself for <code>list</code>s, but the reassignment supports immutable types that aren’t the same object after), which makes it illegal if <code>l1</code> is actually an attribute of an immutable object; for example, <code>t = ([],)</code>, <code>t[0] += lst</code> would fail, while <code>t[0].extend(lst)</code> would work. 2. <code>l1 += l2</code> uses dedicated bytecodes, while <code>l1.extend(l2)</code> uses generalized method dispatch; this makes <code>+=</code> faster than <code>extend</code>.</p></blockquote></li></ul></li><li><p><a href="https://stackoverflow.com/questions/2347265/why-does-behave-unexpectedly-on-lists">Why does += behave unexpectedly on lists?</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;譬如有兩個 list &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，使用 &lt;code&gt;a.extend(b)&lt;/code&gt; 和 &lt;code&gt;a += b&lt;/code&gt; 有什麼相同或不同？有沒有什麼 general 的 best practice for using one rather than the other?&lt;/p&gt;
&lt;p&gt;其實在這個情境下，這兩個用法幾乎一樣。它們都會直接 in-place 的修改 &lt;code&gt;a&lt;/code&gt;，把 &lt;code&gt;b&lt;/code&gt; 裡面的元素加到 &lt;code&gt;a&lt;/code&gt; 的後面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt; 會呼叫 list 的 &lt;code&gt;.__iadd__()&lt;/code&gt; 來做 in-place 的修改&lt;ul&gt;
&lt;li&gt;所以在這個情境下，&lt;code&gt;b&lt;/code&gt; 可以是任何 iterable，譬如 &lt;code&gt;[] += {}&lt;/code&gt; 會得到 &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;假如用 &lt;code&gt;+=&lt;/code&gt; 的是 immutable 的 type，Python 發現沒有 &lt;code&gt;.__iadd__()&lt;/code&gt;，接著就會呼叫它的 &lt;code&gt;.__add__()&lt;/code&gt;，此情況下 &lt;code&gt;a += b&lt;/code&gt; 等同於 &lt;code&gt;a = a + b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列出少數有差別的地方：
    
    </summary>
    
    
      <category term="Development Note" scheme="https://blog.jamesho.website/categories/Development-Note/"/>
    
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>409. Longest Palindrome</title>
    <link href="https://blog.jamesho.website/longest-palindrome/"/>
    <id>https://blog.jamesho.website/longest-palindrome/</id>
    <published>2023-04-14T10:58:18.000Z</published>
    <updated>2023-04-22T10:50:42.537Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindrome/">題目</a><br>思路</p><ol><li>怎麼判斷一個 string 是否為 palindrome？<ul><li>(x) 做一個倒過來的 string 看看兩個是否相等<ul><li>需要 O(n) 時間複雜度，太長了，因為你必須對所有的字串組合做測試</li></ul></li><li>(o) Palindrome 一定是由偶數個數的字母組成，頂多再加上一組奇數個數的字母</li></ul></li><li>先用 dict 記錄每個 character 的個數，再利用計算完成的 dict 來算出答案<a id="more"></a></li></ol><p>想完之後覺得應該蠻簡單，結果寫完送出…… Wrong Answer!</p><figure class="highlight python"><figcaption><span>Wrong Answer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># Build dict for characters.</span></span><br><span class="line">    d = defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        d[c] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    max_odd = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> d.values():</span><br><span class="line">        <span class="keyword">if</span> freq % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            count += freq</span><br><span class="line">        <span class="keyword">elif</span> freq &gt; max_odd:</span><br><span class="line">            max_odd = freq</span><br><span class="line">    <span class="keyword">return</span> count + max_odd</span><br></pre></td></tr></table></figure><p>錯誤之處在於我除了把偶數個數的字母納入之外，只挑了一個出現最多次的奇數字母納入答案，忘了其實奇數個數的字母可以拆成偶數… 所以會少算到很多</p><p>但這樣做完之後，要記得假如裡面有奇數次的字母，最後的答案要再加一</p><figure class="highlight python"><figcaption><span>Python 3 solution：調整後的正確答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># Build dict for character count.</span></span><br><span class="line">    d = defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        d[c] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    odd_complement = <span class="literal">False</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> d.values():</span><br><span class="line">        <span class="keyword">if</span> freq % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            count += freq</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            odd_complement = <span class="literal">True</span></span><br><span class="line">            count += freq - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count + odd_complement</span><br></pre></td></tr></table></figure><p>最後提一下那個 <code>count + odd_complement</code>，Python 在遇到整數和布林值相加的時候，會把布林值轉為整數再相加 (True =&gt; 1, False =&gt; 0)，覺得是還不錯的 feature</p><ul><li>浮點數和布林值相加也類似，會把布林值作轉換後再相加 (True =&gt; 1.0, False =&gt; 0.0)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindrome/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎麼判斷一個 string 是否為 palindrome？&lt;ul&gt;
&lt;li&gt;(x) 做一個倒過來的 string 看看兩個是否相等&lt;ul&gt;
&lt;li&gt;需要 O(n) 時間複雜度，太長了，因為你必須對所有的字串組合做測試&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(o) Palindrome 一定是由偶數個數的字母組成，頂多再加上一組奇數個數的字母&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;先用 dict 記錄每個 character 的個數，再利用計算完成的 dict 來算出答案
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
      <category term="greedy" scheme="https://blog.jamesho.website/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <link href="https://blog.jamesho.website/best-time-to-buy-and-sell-stock/"/>
    <id>https://blog.jamesho.website/best-time-to-buy-and-sell-stock/</id>
    <published>2023-04-14T09:02:18.000Z</published>
    <updated>2023-04-22T10:50:44.223Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">題目</a><br>思路</p><ol><li>最直覺的想法是從頭開始 traverse array，針對每一個 price 都去算一次那個位置之後的所有可能利潤，不過這樣會是兩個巢狀 for-loop，時間複雜度是 O(n^2)，太大了</li><li>有沒有辦法只 traverse 一次 array 就好？</li><li>利潤是由買價和賣價得出，知道最低買價和最高賣價就可以得出答案。有辦法設定這兩個變數，然後隨著 array traversal 不斷更新嗎？<a id="more"></a><ul><li>可以把 <code>最高賣價</code> 改成 <code>最大利潤</code>，因為這個才是需回傳的答案</li></ul></li></ol><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    min_bid = float(<span class="string">'inf'</span>)</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="keyword">if</span> price &lt; min_bid:</span><br><span class="line">            min_bid = price</span><br><span class="line">        <span class="keyword">elif</span> price - min_bid &gt; max_profit:</span><br><span class="line">            max_profit = price - min_bid</span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最直覺的想法是從頭開始 traverse array，針對每一個 price 都去算一次那個位置之後的所有可能利潤，不過這樣會是兩個巢狀 for-loop，時間複雜度是 O(n^2)，太大了&lt;/li&gt;
&lt;li&gt;有沒有辦法只 traverse 一次 array 就好？&lt;/li&gt;
&lt;li&gt;利潤是由買價和賣價得出，知道最低買價和最高賣價就可以得出答案。有辦法設定這兩個變數，然後隨著 array traversal 不斷更新嗎？
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>為什麼 Python 的 in 用在 set 是 O(1) 時間複雜度？</title>
    <link href="https://blog.jamesho.website/why-python-set-o1/"/>
    <id>https://blog.jamesho.website/why-python-set-o1/</id>
    <published>2023-04-14T01:40:15.000Z</published>
    <updated>2023-04-14T02:25:53.172Z</updated>
    
    <content type="html"><![CDATA[<p>通常都會說 Python 的 set 內部是用 hash table 來實作，所以是 O(1)，但為什麼這樣就是 O(1)？</p><p>當要判斷某個元素是否在 set 裡面時，它的 <code>__hash__()</code> 會被用來得到 hash 值，可以把這個 hash 值視為 set 底層實作的 array 的 index，Python 接著會用這個 hash 值去那個 array 的對應位置找，然後發現 array 沒有這個位置，或是找到對應 value，而這個過程跟 set 裡的元素個數無關，所以是 O(1)</p><p>而這邊說的 O(1) 是平均時間複雜度，最壞情況時間複雜度是 O(n)，<a id="more"></a>它發生在不同元素產生相同 hash 的時候，也就是 hash collision。假如有兩個元素的 hash 發生 collision，他們就會被放在同一個 index，可以想像這個 index 的元素變成這兩個元素組成的 linked list，而最差的情況就是所有元素都發生 hash collision，等同於這個 set 變成一個 n 個元素的 linked list，所以判斷一個元素是否在裡面就需要 O(n) 時間複雜度了</p><p><em>參考資料：</em><br><a href="https://qr.ae/prL6P0">Why do sets in Python have an algorithmic complexity of O(1)?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常都會說 Python 的 set 內部是用 hash table 來實作，所以是 O(1)，但為什麼這樣就是 O(1)？&lt;/p&gt;
&lt;p&gt;當要判斷某個元素是否在 set 裡面時，它的 &lt;code&gt;__hash__()&lt;/code&gt; 會被用來得到 hash 值，可以把這個 hash 值視為 set 底層實作的 array 的 index，Python 接著會用這個 hash 值去那個 array 的對應位置找，然後發現 array 沒有這個位置，或是找到對應 value，而這個過程跟 set 裡的元素個數無關，所以是 O(1)&lt;/p&gt;
&lt;p&gt;而這邊說的 O(1) 是平均時間複雜度，最壞情況時間複雜度是 O(n)，
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://blog.jamesho.website/categories/Algorithm/"/>
    
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle II</title>
    <link href="https://blog.jamesho.website/linked-list-cycle-ii/"/>
    <id>https://blog.jamesho.website/linked-list-cycle-ii/</id>
    <published>2023-04-13T12:36:07.000Z</published>
    <updated>2023-04-22T11:03:01.151Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">題目</a><br>思路：最直覺的作法就是從頭開始沿著 next 一直走，然後用一個 set 來存放走過的 node，如果再次走到已走過的 node 就是 cycle 起點 <a id="more"></a></p><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        memo.add(curr)</span><br><span class="line">        curr = curr.next</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>平均時間複雜度：O(n)<ul><li>因為 <code>in</code> 和 <code>add</code> 對於 <code>set</code> 來說都是 O(1)，所以 <code>while</code> 迴圈內每次執行的複雜度為 O(1)</li></ul></li><li>平均空間複雜度：O(n)</li></ul><h3 id="如果想讓空間複雜度是-O-1-呢？"><a href="#如果想讓空間複雜度是-O-1-呢？" class="headerlink" title="如果想讓空間複雜度是 O(1) 呢？"></a>如果想讓空間複雜度是 O(1) 呢？</h3><p>此時必須使用 Floyd’s Cycle Detection algorithm，但假如之前沒看過這個演算法，怎樣的思路最有可能導向用它來解呢？此演算法背後的原理又為何？</p><ol><li><p>Linked list 不要動用額外空間最直覺的解題方式，就是單純靠指標的移動來解，而這題顯然無法靠單一指標做到。那雙指標做得到嗎？</p></li><li><p>假如用快慢雙指標同時從起點出發的話，他們會在 cycle 裡交會，而我們要知道 cycle 起點的唯一方法，就是想辦法讓兩個指標在 cycle 起點交會，如何做到？</p><ul><li>快指標走的速度是慢指標的兩倍</li></ul></li><li><p>想讓指標在 cycle 起點交會，首先必須知道各段距離之間的關聯，我們可以畫個圖，把 起點、cycle 起點、cycle 裡的交會點 先標示出來，利用我們目前已知的條件：<code>在 cycle 裡交會時，快指標走的距離是慢指標的兩倍</code> 來列出方程式，釐清各個距離之間的關係。下面這個影片從 <code>6:37</code> 開始把推導過程講得很清楚 <div class="oembed-outer oembed-youtube"><div class="oembed-inner"><iframe width="500" height="281" src="https://www.youtube.com/embed/wjYnzkAhcNk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Find the Duplicate Number - Floyd&#39;s Cycle Detection - Leetcode 287 - Python"></iframe></div></div></p><ul><li><p>不過影片講解的最後有個地方我覺得可以再多講一下，影片裡一開始假設快指標比慢指標多走了一圈 cycle，最後放寬這個限制，因為快指標有可能多走超過一圈 cycle，此時等式覺得這樣改寫比較容易懂：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * slow = fast</span><br><span class="line"><span class="number">2</span> * (p + c - x) = p + <span class="number">2</span>c - x + nc  <span class="comment"># n 可為 0 或正整數，代表快指標除了已經多走了一圈之外，又再多走的圈數</span></span><br><span class="line">p = x + nc</span><br></pre></td></tr></table></figure><ul><li>最後的 <code>p = x + nc</code> 代表：就算走完 x 還無法會合，只要再多走 n 圈還是會相會，而且一定還是會在 cycle 起始點會合</li></ul></li></ul></li><li><p>如影片裡所說，當快慢指標會合後，把其中一個指標放回原點，再讓兩個指標同速往前，他們的交會點就會是 cycle 起點</p></li><li><p>雖然講完之後感覺程式寫起來蠻簡單，但我一開始還是犯了個小錯誤，一開始寫法如下：</p> <figure class="highlight python"><figcaption><span>Wrong solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:  <span class="comment"># slow 與 fast 交會</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> slow:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        node = node.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p> 有發現錯在哪嗎？當 case 是這張圖 <img src="/images/circularlinkedlist-example.png" alt=""> 的時候，我回傳的 node 是 val 為 2 的 node 而非正確答案。問題出在我沒有考慮到一個情境：當快慢指標會合之後，那個點有可能已經是 cycle 起點了，而當這個起點又剛好是 <code>head</code> 的時候，上面的程式就會出錯</p><ul><li>我錯在假設在 fast &amp; slow 第一次相會之後，slow &amp; node 兩個指標一定要動才會相會，但當 cycle 起點也是 head 的時候，他們不一定要動就可能相會。所以要改的部分就是第 16 行之後，因為它們一定會相遇，<code>while</code> 條件可以改成 <code>while node is not slow:</code>，只要他們還沒相遇就做移動，直到相遇為止</li></ul></li></ol><figure class="highlight python"><figcaption><span>修改後的正確答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:  <span class="comment"># slow 與 fast 交會</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># fast 走到底了兩個都還沒交會</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> slow:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>這邊稍微提一下 Python 的 while-else，它是別的語言比較沒有的用法，但有時候還蠻好用的。<code>else</code> 的內容會在 <code>while</code> 正常結束時被執行，也就是當 <code>while</code> 被 <code>break</code> 之後，是不會執行 <code>else</code> 內容的。所以這邊的用法就是：</p><ul><li>當 slow 與 fast 交會，就繼續往下做</li><li>當 fast 走到底了兩個都還沒交會，就是沒有 cycle，此時直接 <code>return</code></li></ul><p>如果不用 while-else，就必須在 <code>while</code> 後面寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>相對來說比較沒那麼簡潔</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle-ii/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路：最直覺的作法就是從頭開始沿著 next 一直走，然後用一個 set 來存放走過的 node，如果再次走到已走過的 node 就是 cycle 起點
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="two pointers" scheme="https://blog.jamesho.website/tags/two-pointers/"/>
    
      <category term="linked list" scheme="https://blog.jamesho.website/tags/linked-list/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="https://blog.jamesho.website/reverse-linked-list/"/>
    <id>https://blog.jamesho.website/reverse-linked-list/</id>
    <published>2023-04-13T01:04:56.000Z</published>
    <updated>2023-04-22T10:50:47.789Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-linked-list/">題目</a><br>思路</p><ol><li>因為是 linked list，我們可以使用 <code>curr</code> 當指標，沿著 linked list 的頭往後走，一邊改變 <code>curr.next</code> 的指向，而過程中必須對前一個和下一個都有所掌握，因為 <code>curr</code> 必須指向前一個，然後它本身必須換到下一個</li><li>所以我們會有三個變數：<code>previous</code>, <code>curr</code>, <code>next</code></li><li>當 <code>curr</code> 是 <code>head</code> 時，<code>previous</code> 會是 <code>None</code>，這兩個可以先設定好。目標是一直改變 <code>curr</code> 的指向，讓 <code>curr</code> 一直走到 linked list 盡頭，變成 <code>None</code> 為止，所以 <code>while</code> 條件就是 <code>當有 curr 的時候就做</code><a id="more"></a></li></ol><p>Python 3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    previous = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        next = curr.next</span><br><span class="line">        curr.next = previous</span><br><span class="line">        previous = curr</span><br><span class="line">        curr = next</span><br><span class="line">    <span class="keyword">return</span> previous</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為是 linked list，我們可以使用 &lt;code&gt;curr&lt;/code&gt; 當指標，沿著 linked list 的頭往後走，一邊改變 &lt;code&gt;curr.next&lt;/code&gt; 的指向，而過程中必須對前一個和下一個都有所掌握，因為 &lt;code&gt;curr&lt;/code&gt; 必須指向前一個，然後它本身必須換到下一個&lt;/li&gt;
&lt;li&gt;所以我們會有三個變數：&lt;code&gt;previous&lt;/code&gt;, &lt;code&gt;curr&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;當 &lt;code&gt;curr&lt;/code&gt; 是 &lt;code&gt;head&lt;/code&gt; 時，&lt;code&gt;previous&lt;/code&gt; 會是 &lt;code&gt;None&lt;/code&gt;，這兩個可以先設定好。目標是一直改變 &lt;code&gt;curr&lt;/code&gt; 的指向，讓 &lt;code&gt;curr&lt;/code&gt; 一直走到 linked list 盡頭，變成 &lt;code&gt;None&lt;/code&gt; 為止，所以 &lt;code&gt;while&lt;/code&gt; 條件就是 &lt;code&gt;當有 curr 的時候就做&lt;/code&gt;
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="linked list" scheme="https://blog.jamesho.website/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Isomorphic Strings</title>
    <link href="https://blog.jamesho.website/isomorphic-strings/"/>
    <id>https://blog.jamesho.website/isomorphic-strings/</id>
    <published>2023-04-12T08:29:09.000Z</published>
    <updated>2023-04-22T10:50:49.933Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/isomorphic-strings/">題目</a><br>這題看似不難，但第一次的做法錯了，第一次的程式碼如下，想法是用 mapping 組一個新字串 <code>t2</code>，假如跟 <code>t</code> 相同就 return True</p><p>Python 3 wrong solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        d[s[i]] = t[i]</span><br><span class="line">    t2 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        t2 += d[c]</span><br><span class="line">    <span class="keyword">return</span> t == t2</span><br></pre></td></tr></table></figure><a id="more"></a><p>測出錯誤的 input:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"badc"</span></span><br><span class="line">t = <span class="string">"baba"</span></span><br></pre></td></tr></table></figure><p>錯誤點在於沒有檢查這個條件：<code>No two characters may map to the same character</code></p><p>檢討如下：</p><ul><li>寫完要 run 之前應該最後 check 一次是否有滿足題目提到的所有條件</li><li>以這題來說，比較好的做法是一個個 check 每個 character<ul><li>這樣只需跑一次 for-loop，不需要再跑第二次組一個新字串</li><li>每個 character 都 check 就不會漏掉上面那個條件</li></ul></li></ul><h3 id="修正解法如下"><a href="#修正解法如下" class="headerlink" title="修正解法如下"></a>修正解法如下</h3><p>Python 3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    mapping = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> mapping.values():  <span class="comment"># 一個 t 字母同時對應到兩個 s 字母</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            mapping[s[i]] = t[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mapping[s[i]] != t[i]:  <span class="comment"># 一個 s 字母同時對應到兩個 t 字母</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/isomorphic-strings/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;這題看似不難，但第一次的做法錯了，第一次的程式碼如下，想法是用 mapping 組一個新字串 &lt;code&gt;t2&lt;/code&gt;，假如跟 &lt;code&gt;t&lt;/code&gt; 相同就 return True&lt;/p&gt;
&lt;p&gt;Python 3 wrong solution:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isIsomorphic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, s: str, t: str)&lt;/span&gt; -&amp;gt; bool:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(s)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d[s[i]] = t[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t2 = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t2 += d[c]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t == t2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>Binary Number with Alternating Bits</title>
    <link href="https://blog.jamesho.website/binary-number-with-alternating-bits/"/>
    <id>https://blog.jamesho.website/binary-number-with-alternating-bits/</id>
    <published>2023-04-12T05:26:05.000Z</published>
    <updated>2023-04-22T10:50:51.424Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/">題目</a></p><ol><li>先想到的是有沒有辦法透過 bitwise operation 來判斷，發現無法</li><li>看相鄰位置有沒有一樣的，最直覺就是用字串來判斷 =&gt; 可以利用 Python 的 built-in function <code>bin</code> 來把數字轉為 binary 字串</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">    b_str = bin(n)[<span class="number">2</span>:]  <span class="comment"># 去掉前面的 '0b'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b_str) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> b_str[i] == b_str[i + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-number-with-alternating-bits/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先想到的是有沒有辦法透過 bitwise operation 來判斷，發現無法&lt;
      
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="bit manipulation" scheme="https://blog.jamesho.website/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="https://blog.jamesho.website/single-number/"/>
    <id>https://blog.jamesho.website/single-number/</id>
    <published>2023-04-12T04:10:25.000Z</published>
    <updated>2023-04-22T10:50:52.932Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/single-number/">題目</a></p><ol><li>因為只能用常數的額外空間，且 array 裡的數字除了目標之外都會有<strong>兩</strong>個，所以朝 bitwise operation 的方向想</li><li>把 array 裡所有數字接連做 bitwise operation，假如有兩個一樣的數字，他們就會抵銷變為 0，即使不是連著做也一樣，所以最後的結果就是那個落單的數字<ul><li>可以想像所有數字都用二進位表示由上而下列在一起做計算，不管他們位置怎麼換結果都會一樣 (偶數個 <code>1</code> 會互相抵銷)</li></ul></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        r ^= i</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為只能用常數的額外空間，且 array 裡的數字除了目標之外都會有&lt;strong&gt;兩&lt;/strong&gt;個，所以朝 bitw
      
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
      <category term="bit manipulation" scheme="https://blog.jamesho.website/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Validate Binary Search Tree</title>
    <link href="https://blog.jamesho.website/validate-binary-search-tree/"/>
    <id>https://blog.jamesho.website/validate-binary-search-tree/</id>
    <published>2023-04-12T01:11:56.000Z</published>
    <updated>2023-04-30T04:27:31.012Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">題目</a><br>思路</p><ol><li>樹的問題用遞迴來解相對上比較直覺，所以先試試遞迴解</li><li>拆解到最小單位來找 recursive case: 隨機取樹中一個點，判斷它是否 valid</li><li>大部分情況都會有上下限。以左邊的點為例，上限就是父節點的值，下限就是它所在的右子樹的父節點的值，所以這個值必須由上到下一層層傳遞下來。反之，右邊的點的話，就變成上限必須一層層傳遞下來</li><li>因為上下限必須用傳遞的，所以寫一個 function <code>node_valid</code> 接受上下限的參數<a id="more"></a></li></ol><figure class="highlight python"><figcaption><span>Python 3 Recursive Solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_valid</span><span class="params">(node, floor=float<span class="params">(<span class="string">'-inf'</span>)</span>, ceiling=float<span class="params">(<span class="string">'inf'</span>)</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        v = node.val</span><br><span class="line">        <span class="keyword">if</span> v &lt;= floor <span class="keyword">or</span> v &gt;= ceiling:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> node_valid(node.left, floor, v) <span class="keyword">and</span> node_valid(node.right, v, ceiling)</span><br><span class="line">    <span class="keyword">return</span> node_valid(root)</span><br></pre></td></tr></table></figure><p>假設樹有 n 個 node</p><ul><li>時間複雜度：O(n)<ul><li>因為每個點都會做一次，而每次的複雜度為 O(1)</li><li><a name="time-complexity-example"></a>另一個算法可參考<a href="/recursion-time-complexity">這邊</a>的快速解：<ul><li><code>node_valid(root)</code> 的遞迴深度為這棵樹的深度，在樹為平衡的情況下，深度為 log2 n，所以複雜度為 O(2^(log2 n)) = O(n)</li></ul></li></ul></li></ul><h3 id="接下來嘗試用迭代解"><a href="#接下來嘗試用迭代解" class="headerlink" title="接下來嘗試用迭代解"></a>接下來嘗試用迭代解</h3><ol><li>可以用跟遞迴類似的思路，只是改成把要處理的 nodes 都放到 stack 裡，然後每次迴圈都從裡面拿一個出來做，一直做到 stack 為空。迴圈裡的內容就是 recursive case</li><li>因為 floor 和 ceiling 必須一直傳下去，所以跟 node 一起包成 tuple 放入 stack</li></ol><figure class="highlight python"><figcaption><span>Python 3 Iterative Solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    stack = [(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))]  <span class="comment"># node, floor, ceiling</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, floor, ceiling = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        v = node.val</span><br><span class="line">        <span class="keyword">if</span> v &lt;= floor <span class="keyword">or</span> v &gt;= ceiling:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack.extend([</span><br><span class="line">            (node.left, floor, v),</span><br><span class="line">            (node.right, v, ceiling)</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/validate-binary-search-tree/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;樹的問題用遞迴來解相對上比較直覺，所以先試試遞迴解&lt;/li&gt;
&lt;li&gt;拆解到最小單位來找 recursive case: 隨機取樹中一個點，判斷它是否 valid&lt;/li&gt;
&lt;li&gt;大部分情況都會有上下限。以左邊的點為例，上限就是父節點的值，下限就是它所在的右子樹的父節點的值，所以這個值必須由上到下一層層傳遞下來。反之，右邊的點的話，就變成上限必須一層層傳遞下來&lt;/li&gt;
&lt;li&gt;因為上下限必須用傳遞的，所以寫一個 function &lt;code&gt;node_valid&lt;/code&gt; 接受上下限的參數
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="binary search tree" scheme="https://blog.jamesho.website/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>使用 Dokku 將 Web App 部署在 DigitalOcean</title>
    <link href="https://blog.jamesho.website/use-dokku-on-digitalocean/"/>
    <id>https://blog.jamesho.website/use-dokku-on-digitalocean/</id>
    <published>2023-04-05T07:37:28.000Z</published>
    <updated>2023-07-04T16:11:24.479Z</updated>
    
    <content type="html"><![CDATA[<p>因為 Heroku 現在要收費了，原本放在上面<a href="https://github.com/james687/Tweetme">用免費方案的 project</a> 就需要找新的方法。於是找到了 <a href="https://github.com/dokku/dokku">Dokku</a>，他的 GitHub page 介紹如下：</p><blockquote><p>Docker powered mini-Heroku. The smallest PaaS implementation you’ve ever seen.</p></blockquote><p>的確是很傳神，因為使用方法跟 Heroku 很像，基本上可以從 Heroku 無痛遷移，差別在你需要用自己的 VM &amp; domain，配合 dokku 就可以在上面用 docker 管理你的 application，就像他的 about 寫的：<a id="more"></a></p><blockquote><p>A docker-powered PaaS that helps you build and manage the lifecycle of applications</p></blockquote><p>這邊使用 DigitalOcean 的 droplet，因為他有兩個月 200 美金的試用 credits，假如只是短期測試專案的話也夠了，不然也可以兩個月換一個新帳號 😅</p><p>這邊稍微筆記一下把 Heroku 專案搬過來的過程：</p><ul><li>在 DigitalOcean 創一個 droplet, 在上面照著<a href="https://dokku.com/docs/getting-started/installation/">文件</a>的步驟做，droplet OS 需選擇 dokku 支援的版本</li><li><code>dokku apps:create {app_name}</code></li><li><code>sudo dokku plugin:install https://github.com/dokku/dokku-postgres.git postgres</code></li><li>使用 subdomain 的步驟：<ol><li><code>dokku domains:set-global {domain}</code></li><li><code>dokku domains:set {dokku_app_name} {subdomain.domain}</code></li><li>設定 domain 的 A record, CNAME<ul><li>A record: <ul><li>Host: <code>@</code></li><li>Value: droplet IP</li></ul></li><li>CNAME<ul><li>Host: subdomain</li><li>Value: <code>{domain}.</code></li></ul></li></ul></li></ol><ul><li>看起來這個方法應該可以讓我們在同一個 droplet 裡，用不同的 subdomains 跑多個不同的 web apps。只要分別設定多個 CNAME 和對應的 dokku app domain 就好<ul><li>流程：{subdomain_a.domain} 的 request 依循 IP 到了該 droplet 的 nginx，nginx 再將 request 導到 subdomain_a 對應的 dokku app</li></ul></li><li>如果單純只想讓 <code>{dokku_app_name}.{domain}</code> 指到 dokku app，也可以只設定 A record:<ul><li>Host: <code>dokku_app_name</code></li><li>Value: droplet IP</li></ul></li></ul></li><li><code>dokku config:set {dokku_app_name} KEY=value</code> 可設定需要的環境變數</li><li>可以用 runtime.txt 指定 python 執行的版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因為 Heroku 現在要收費了，原本放在上面&lt;a href=&quot;https://github.com/james687/Tweetme&quot;&gt;用免費方案的 project&lt;/a&gt; 就需要找新的方法。於是找到了 &lt;a href=&quot;https://github.com/dokku/dokku&quot;&gt;Dokku&lt;/a&gt;，他的 GitHub page 介紹如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker powered mini-Heroku. The smallest PaaS implementation you’ve ever seen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的確是很傳神，因為使用方法跟 Heroku 很像，基本上可以從 Heroku 無痛遷移，差別在你需要用自己的 VM &amp;amp; domain，配合 dokku 就可以在上面用 docker 管理你的 application，就像他的 about 寫的：
    
    </summary>
    
    
      <category term="Development Note" scheme="https://blog.jamesho.website/categories/Development-Note/"/>
    
    
      <category term="docker" scheme="https://blog.jamesho.website/tags/docker/"/>
    
      <category term="heroku" scheme="https://blog.jamesho.website/tags/heroku/"/>
    
      <category term="dokku" scheme="https://blog.jamesho.website/tags/dokku/"/>
    
      <category term="paas" scheme="https://blog.jamesho.website/tags/paas/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="https://blog.jamesho.website/binary-tree-level-order-traversal/"/>
    <id>https://blog.jamesho.website/binary-tree-level-order-traversal/</id>
    <published>2023-03-28T11:25:25.000Z</published>
    <updated>2023-04-22T10:50:56.352Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">題目</a><br>思路</p><ol><li>一次一層很直覺想到廣先搜尋 (BFS)，所以用 iterative 的做法來解</li><li>一次迴圈處理一層，並把下一層節點放入 stack 繼續在下次迴圈處理<ul><li>stack 也是 list of list, 裡面的每個 list 都是一層節點<a id="more"></a></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack, values = [[root]], []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        level_vals = []</span><br><span class="line">        level_nodes = []</span><br><span class="line">        nodes = stack.pop()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            level_vals.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                level_nodes.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                level_nodes.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> level_nodes:</span><br><span class="line">            stack.append(level_nodes)</span><br><span class="line">        values.append(level_vals)</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="但假如用遞迴的話怎麼解？"><a href="#但假如用遞迴的話怎麼解？" class="headerlink" title="但假如用遞迴的話怎麼解？"></a>但假如用遞迴的話怎麼解？</h3><p>Recursive case: 把當下這個節點的 value 放到對應 level index 的 list 中</p><ul><li><p>如果沒有對應的 level index 就加一個空 list 進去 (<code>level_ind</code> 會從 0 開始依序傳入，不會有跳號的情況)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    level = res[level_ind]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    level = []</span><br><span class="line">    res.append(level)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_value</span><span class="params">(node, level_ind, res)</span>:</span></span><br><span class="line">        <span class="comment"># Base case</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursive case</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            level = res[level_ind]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            level = []</span><br><span class="line">            res.append(level)</span><br><span class="line">        level.append(node.val)</span><br><span class="line">        put_value(node.left, level_ind + <span class="number">1</span>, res)</span><br><span class="line">        put_value(node.right, level_ind + <span class="number">1</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    put_value(root, <span class="number">0</span>, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一次一層很直覺想到廣先搜尋 (BFS)，所以用 iterative 的做法來解&lt;/li&gt;
&lt;li&gt;一次迴圈處理一層，並把下一層節點放入 stack 繼續在下次迴圈處理&lt;ul&gt;
&lt;li&gt;stack 也是 list of list, 裡面的每個 list 都是一層節點
    
    </summary>
    
    
      <category term="LeetCode Digest" scheme="https://blog.jamesho.website/categories/LeetCode-Digest/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="breadth-first search" scheme="https://blog.jamesho.website/tags/breadth-first-search/"/>
    
  </entry>
  
</feed>
