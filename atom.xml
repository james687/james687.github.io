<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>James&#39; Blog</title>
  
  <subtitle>程式隨筆</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.jamesho.website/"/>
  <updated>2023-04-18T06:41:45.493Z</updated>
  <id>https://blog.jamesho.website/</id>
  
  <author>
    <name>James Ho</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>589. N-ary Tree Preorder Traversal</title>
    <link href="https://blog.jamesho.website/n-ary-tree-preorder-traversal/"/>
    <id>https://blog.jamesho.website/n-ary-tree-preorder-traversal/</id>
    <published>2023-04-18T05:59:22.000Z</published>
    <updated>2023-04-18T06:41:45.493Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/n-ary-tree-preorder-traversal/">題目</a><br>思路</p><ol><li>樹的問題會先從遞迴來想比較直觀，首先找出最小可重複動作來作為 recursive case</li><li>先假設我們可以用題目給的 method 直接當作遞迴的函式，也就是說我們遞迴函式的回傳，是 preorder 排序的 node values</li><li>最小可重複動作：對於我這個 node 來說，回傳 preordered values</li></ol><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    result = [root.val]</span><br><span class="line">    <span class="keyword">for</span> child <span class="keyword">in</span> root.children <span class="keyword">or</span> []:</span><br><span class="line">        result.extend(self.preorder(child))</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="假如用迭代的方式來解呢？"><a href="#假如用迭代的方式來解呢？" class="headerlink" title="假如用迭代的方式來解呢？"></a>假如用迭代的方式來解呢？</h3><ol><li>用 stack, 把要處理的放入，迴圈內每次都拿一個出來，做 <code>最小可重複動作</code>，做到 stack 沒東西為止</li><li>注意在放入 <code>child</code> 的時候這邊是用 reverse order 來放，因為我到時候拿出來的時候想用 <code>.pop()</code>(O(1) 時間複雜度) 而不是 <code>.pop(0)</code>(O(n) 時間複雜度)</li></ol><figure class="highlight python"><figcaption><span>Python 3 iterative solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack = [root]</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node = stack.pop()</span><br><span class="line">        res.append(node.val)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node.children:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> reversed(node.children):</span><br><span class="line">            stack.append(child)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/n-ary-tree-preorder-traversal/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;樹的問題會先從遞迴來想比較直觀，首先找出最小可重複動作來作為 recursive case&lt;/li&gt;
&lt;li&gt;先假設我們可以用題目給的 method 直接當作遞迴的函式，也就是說我們遞迴函式的回傳，是 preorder 排序的 node values&lt;/li&gt;
&lt;li&gt;最小可重複動作：對於我這個 node 來說，回傳 preordered values&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;figcaption&gt;&lt;span&gt;Python 3 solution&lt;/span&gt;&lt;/figcaption&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preorder&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, root: &lt;span class=&quot;string&quot;&gt;&#39;Node&#39;&lt;/span&gt;)&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; root:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    result = [root.val]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; child &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; root.children &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; []:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.extend(self.preorder(child))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="stack" scheme="https://blog.jamesho.website/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>[Python] list 用 `.extend()` 與 `+=` 的差別</title>
    <link href="https://blog.jamesho.website/diff-between-extend-and-plusequal/"/>
    <id>https://blog.jamesho.website/diff-between-extend-and-plusequal/</id>
    <published>2023-04-17T07:19:11.000Z</published>
    <updated>2023-04-17T07:45:25.668Z</updated>
    
    <content type="html"><![CDATA[<p>譬如有兩個 list <code>a</code> 和 <code>b</code>，使用 <code>a.extend(b)</code> 和 <code>a += b</code> 有什麼相同或不同？有沒有什麼 general 的 best practice for using one rather than the other?</p><p>其實在這個情境下，這兩個用法幾乎一樣。它們都會直接 in-place 的修改 <code>a</code>，把 <code>b</code> 裡面的元素加到 <code>a</code> 的後面</p><ul><li><code>+=</code> 會呼叫 list 的 <code>.__iadd__()</code> 來做 in-place 的修改<ul><li>所以在這個情境下，<code>b</code> 可以是任何 iterable，譬如 <code>[] += {}</code> 會得到 <code>[]</code></li><li>假如用 <code>+=</code> 的是 immutable 的 type，Python 發現沒有 <code>.__iadd__()</code>，接著就會呼叫它的 <code>.__add__()</code>，此情況下 <code>a += b</code> 等同於 <code>a = a + b</code></li></ul></li></ul><p>以下列出少數有差別的地方：<a id="more"></a></p><ul><li><code>+=</code> 不能用在 tuple 裡的 list，但 <code>.extend()</code> 可以<ul><li>雖然說 <code>+=</code> 所呼叫的 <code>.__iadd__()</code> 是 in-place 修改，做完後 <code>a</code> 的 reference 還是會一樣，但過程中還是會以某種方式動到 reference，只是最後會有個 reassign 給自己的動作<a href="#anno1">[註1]</a>，所以會有一樣的 reference</li></ul></li><li><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend/24261311#24261311"><code>+=</code> 不能用在 non-local variable，但 <code>.extend()</code> 可以</a></li><li><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend/37762884#37762884"><code>+=</code> 不能 chain function call, 但 <code>.extend()</code> 可以</a></li><li>兩者速度依不同情況稍有差異<ul><li>可參考<a href="#anno1">註1</a>這個 comment 下兩個接續的 comments: <a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754463_28119966">comment 1</a>, <a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754732_28119966">comment 2</a></li></ul></li></ul><p><strong>結論</strong><br>可以都用 <code>.extend()</code> 就好，consistency 也是一個重點。對於有差別的部分，一般情況下速度的差異可以忽略，其他的差別都是 <code>.extend()</code> 比較好，而且它在語意上的描述也也更貼切。</p><p><em>參考資料：</em></p><ul><li><p><a href="https://stackoverflow.com/questions/3653298/concatenating-two-lists-difference-between-and-extend">Concatenating two lists - difference between ‘+=’ and extend()</a></p></li><li><p><a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend">What is the difference between Python’s list methods append and extend?</a></p><ul><li><p><a name="anno1"></a><a href="https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend#comment90754266_28119966">註1</a>:</p><blockquote><p><code>l1 += l2</code> and <code>l1.extend(l2)</code> ultimately execute the same code (the <code>list_extend</code> function in <code>listobject.c</code>). The only differences are: 1. <code>+=</code> reassigns <code>l1</code> (to itself for <code>list</code>s, but the reassignment supports immutable types that aren’t the same object after), which makes it illegal if <code>l1</code> is actually an attribute of an immutable object; for example, <code>t = ([],)</code>, <code>t[0] += lst</code> would fail, while <code>t[0].extend(lst)</code> would work. 2. <code>l1 += l2</code> uses dedicated bytecodes, while <code>l1.extend(l2)</code> uses generalized method dispatch; this makes <code>+=</code> faster than <code>extend</code>.</p></blockquote></li></ul></li><li><p><a href="https://stackoverflow.com/questions/2347265/why-does-behave-unexpectedly-on-lists">Why does += behave unexpectedly on lists?</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;譬如有兩個 list &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt;，使用 &lt;code&gt;a.extend(b)&lt;/code&gt; 和 &lt;code&gt;a += b&lt;/code&gt; 有什麼相同或不同？有沒有什麼 general 的 best practice for using one rather than the other?&lt;/p&gt;
&lt;p&gt;其實在這個情境下，這兩個用法幾乎一樣。它們都會直接 in-place 的修改 &lt;code&gt;a&lt;/code&gt;，把 &lt;code&gt;b&lt;/code&gt; 裡面的元素加到 &lt;code&gt;a&lt;/code&gt; 的後面&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt; 會呼叫 list 的 &lt;code&gt;.__iadd__()&lt;/code&gt; 來做 in-place 的修改&lt;ul&gt;
&lt;li&gt;所以在這個情境下，&lt;code&gt;b&lt;/code&gt; 可以是任何 iterable，譬如 &lt;code&gt;[] += {}&lt;/code&gt; 會得到 &lt;code&gt;[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;假如用 &lt;code&gt;+=&lt;/code&gt; 的是 immutable 的 type，Python 發現沒有 &lt;code&gt;.__iadd__()&lt;/code&gt;，接著就會呼叫它的 &lt;code&gt;.__add__()&lt;/code&gt;，此情況下 &lt;code&gt;a += b&lt;/code&gt; 等同於 &lt;code&gt;a = a + b&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下列出少數有差別的地方：
    
    </summary>
    
    
      <category term="Development Note" scheme="https://blog.jamesho.website/categories/Development-Note/"/>
    
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>409. Longest Palindrome</title>
    <link href="https://blog.jamesho.website/longest-palindrome/"/>
    <id>https://blog.jamesho.website/longest-palindrome/</id>
    <published>2023-04-14T10:58:18.000Z</published>
    <updated>2023-04-14T11:41:08.679Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/longest-palindrome/">題目</a><br>思路</p><ol><li>怎麼判斷一個 string 是否為 palindrome？<ul><li>(x) 做一個倒過來的 string 看看兩個是否相等<ul><li>需要 O(n) 時間複雜度，太長了，因為你必須對所有的字串組合做測試</li></ul></li><li>(o) Palindrome 一定是由偶數個數的字母組成，頂多再加上一組奇數個數的字母</li></ul></li><li>先用 dict 記錄每個 character 的個數，再利用計算完成的 dict 來算出答案<a id="more"></a></li></ol><p>想完之後覺得應該蠻簡單，結果寫完送出…… Wrong Answer!</p><figure class="highlight python"><figcaption><span>Wrong Answer</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># Build dict for characters.</span></span><br><span class="line">    d = defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        d[c] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    max_odd = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> d.values():</span><br><span class="line">        <span class="keyword">if</span> freq % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            count += freq</span><br><span class="line">        <span class="keyword">elif</span> freq &gt; max_odd:</span><br><span class="line">            max_odd = freq</span><br><span class="line">    <span class="keyword">return</span> count + max_odd</span><br></pre></td></tr></table></figure><p>錯誤之處在於我除了把偶數個數的字母納入之外，只挑了一個出現最多次的奇數字母納入答案，忘了其實奇數個數的字母可以拆成偶數… 所以會少算到很多</p><p>但這樣做完之後，要記得假如裡面有奇數次的字母，最後的答案要再加一</p><figure class="highlight python"><figcaption><span>Python 3 solution：調整後的正確答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># Build dict for character count.</span></span><br><span class="line">    d = defaultdict(int)</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        d[c] += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    odd_complement = <span class="literal">False</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> freq <span class="keyword">in</span> d.values():</span><br><span class="line">        <span class="keyword">if</span> freq % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            count += freq</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            odd_complement = <span class="literal">True</span></span><br><span class="line">            count += freq - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count + odd_complement</span><br></pre></td></tr></table></figure><p>最後提一下那個 <code>count + odd_complement</code>，Python 在遇到整數和布林值相加的時候，會把布林值轉為整數再相加 (True =&gt; 1, False =&gt; 0)，覺得是還不錯的 feature</p><ul><li>浮點數和布林值相加也類似，會把布林值作轉換後再相加 (True =&gt; 1.0, False =&gt; 0.0)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/longest-palindrome/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;怎麼判斷一個 string 是否為 palindrome？&lt;ul&gt;
&lt;li&gt;(x) 做一個倒過來的 string 看看兩個是否相等&lt;ul&gt;
&lt;li&gt;需要 O(n) 時間複雜度，太長了，因為你必須對所有的字串組合做測試&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(o) Palindrome 一定是由偶數個數的字母組成，頂多再加上一組奇數個數的字母&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;先用 dict 記錄每個 character 的個數，再利用計算完成的 dict 來算出答案
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
      <category term="greedy" scheme="https://blog.jamesho.website/tags/greedy/"/>
    
  </entry>
  
  <entry>
    <title>121. Best Time to Buy and Sell Stock</title>
    <link href="https://blog.jamesho.website/best-time-to-buy-and-sell-stock/"/>
    <id>https://blog.jamesho.website/best-time-to-buy-and-sell-stock/</id>
    <published>2023-04-14T09:02:18.000Z</published>
    <updated>2023-04-14T09:49:06.992Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/">題目</a><br>思路</p><ol><li>最直覺的想法是從頭開始 traverse array，針對每一個 price 都去算一次那個位置之後的所有可能利潤，不過這樣會是兩個巢狀 for-loop，時間複雜度是 O(n^2)，太大了</li><li>有沒有辦法只 traverse 一次 array 就好？</li><li>利潤是由買價和賣價得出，知道最低買價和最高賣價就可以得出答案。有辦法設定這兩個變數，然後隨著 array traversal 不斷更新嗎？<a id="more"></a><ul><li>可以把 <code>最高賣價</code> 改成 <code>最大利潤</code>，因為這個才是需回傳的答案</li></ul></li></ol><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">    min_bid = float(<span class="string">'inf'</span>)</span><br><span class="line">    max_profit = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">        <span class="keyword">if</span> price &lt; min_bid:</span><br><span class="line">            min_bid = price</span><br><span class="line">        <span class="keyword">elif</span> price - min_bid &gt; max_profit:</span><br><span class="line">            max_profit = price - min_bid</span><br><span class="line">    <span class="keyword">return</span> max_profit</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最直覺的想法是從頭開始 traverse array，針對每一個 price 都去算一次那個位置之後的所有可能利潤，不過這樣會是兩個巢狀 for-loop，時間複雜度是 O(n^2)，太大了&lt;/li&gt;
&lt;li&gt;有沒有辦法只 traverse 一次 array 就好？&lt;/li&gt;
&lt;li&gt;利潤是由買價和賣價得出，知道最低買價和最高賣價就可以得出答案。有辦法設定這兩個變數，然後隨著 array traversal 不斷更新嗎？
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>為什麼 Python 的 in 用在 set 是 O(1) 時間複雜度？</title>
    <link href="https://blog.jamesho.website/why-python-set-o1/"/>
    <id>https://blog.jamesho.website/why-python-set-o1/</id>
    <published>2023-04-14T01:40:15.000Z</published>
    <updated>2023-04-14T02:25:53.172Z</updated>
    
    <content type="html"><![CDATA[<p>通常都會說 Python 的 set 內部是用 hash table 來實作，所以是 O(1)，但為什麼這樣就是 O(1)？</p><p>當要判斷某個元素是否在 set 裡面時，它的 <code>__hash__()</code> 會被用來得到 hash 值，可以把這個 hash 值視為 set 底層實作的 array 的 index，Python 接著會用這個 hash 值去那個 array 的對應位置找，然後發現 array 沒有這個位置，或是找到對應 value，而這個過程跟 set 裡的元素個數無關，所以是 O(1)</p><p>而這邊說的 O(1) 是平均時間複雜度，最壞情況時間複雜度是 O(n)，<a id="more"></a>它發生在不同元素產生相同 hash 的時候，也就是 hash collision。假如有兩個元素的 hash 發生 collision，他們就會被放在同一個 index，可以想像這個 index 的元素變成這兩個元素組成的 linked list，而最差的情況就是所有元素都發生 hash collision，等同於這個 set 變成一個 n 個元素的 linked list，所以判斷一個元素是否在裡面就需要 O(n) 時間複雜度了</p><p><em>參考資料：</em><br><a href="https://qr.ae/prL6P0">Why do sets in Python have an algorithmic complexity of O(1)?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常都會說 Python 的 set 內部是用 hash table 來實作，所以是 O(1)，但為什麼這樣就是 O(1)？&lt;/p&gt;
&lt;p&gt;當要判斷某個元素是否在 set 裡面時，它的 &lt;code&gt;__hash__()&lt;/code&gt; 會被用來得到 hash 值，可以把這個 hash 值視為 set 底層實作的 array 的 index，Python 接著會用這個 hash 值去那個 array 的對應位置找，然後發現 array 沒有這個位置，或是找到對應 value，而這個過程跟 set 裡的元素個數無關，所以是 O(1)&lt;/p&gt;
&lt;p&gt;而這邊說的 O(1) 是平均時間複雜度，最壞情況時間複雜度是 O(n)，
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://blog.jamesho.website/categories/Algorithm/"/>
    
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>142. Linked List Cycle II</title>
    <link href="https://blog.jamesho.website/linked-list-cycle-ii/"/>
    <id>https://blog.jamesho.website/linked-list-cycle-ii/</id>
    <published>2023-04-13T12:36:07.000Z</published>
    <updated>2023-04-13T12:50:36.222Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/linked-list-cycle-ii/">題目</a><br>思路：最直覺的作法就是從頭開始沿著 next 一直走，然後用一個 set 來存放走過的 node，如果再次走到已走過的 node 就是 cycle 起點 <a id="more"></a></p><figure class="highlight python"><figcaption><span>Python 3 solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    visited = set()</span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        <span class="keyword">if</span> curr <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> curr</span><br><span class="line">        memo.add(curr)</span><br><span class="line">        curr = curr.next</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><ul><li>平均時間複雜度：O(n)<ul><li>因為 <code>in</code> 和 <code>add</code> 對於 <code>set</code> 來說都是 O(1)，所以 <code>while</code> 迴圈內每次執行的複雜度為 O(1)</li></ul></li><li>平均空間複雜度：O(n)</li></ul><h3 id="如果想讓空間複雜度是-O-1-呢？"><a href="#如果想讓空間複雜度是-O-1-呢？" class="headerlink" title="如果想讓空間複雜度是 O(1) 呢？"></a>如果想讓空間複雜度是 O(1) 呢？</h3><p>此時必須使用 Floyd’s Cycle Detection algorithm，但假如之前沒看過這個演算法，怎樣的思路最有可能導向用它來解呢？此演算法背後的原理又為何？</p><ol><li><p>Linked list 不要動用額外空間最直覺的解題方式，就是單純靠指標的移動來解，而這題顯然無法靠單一指標做到。那雙指標做得到嗎？</p></li><li><p>假如用快慢雙指標同時從起點出發的話，他們會在 cycle 裡交會，而我們要知道 cycle 起點的唯一方法，就是想辦法讓兩個指標在 cycle 起點交會，如何做到？</p><ul><li>快指標走的速度是慢指標的兩倍</li></ul></li><li><p>想讓指標在 cycle 起點交會，首先必須知道各段距離之間的關聯，我們可以畫個圖，把 起點、cycle 起點、cycle 裡的交會點 先標示出來，利用我們目前已知的條件：<code>在 cycle 裡交會時，快指標走的距離是慢指標的兩倍</code> 來列出方程式，釐清各個距離之間的關係。下面這個影片從 <code>6:37</code> 開始把推導過程講得很清楚 <div class="oembed-outer oembed-youtube"><div class="oembed-inner"><iframe width="500" height="281" src="https://www.youtube.com/embed/wjYnzkAhcNk?feature=oembed" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen title="Find the Duplicate Number - Floyd&#39;s Cycle Detection - Leetcode 287 - Python"></iframe></div></div></p><ul><li><p>不過影片講解的最後有個地方我覺得可以再多講一下，影片裡一開始假設快指標比慢指標多走了一圈 cycle，最後放寬這個限制，因為快指標有可能多走超過一圈 cycle，此時等式覺得這樣改寫比較容易懂：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> * slow = fast</span><br><span class="line"><span class="number">2</span> * (p + c - x) = p + <span class="number">2</span>c - x + nc  <span class="comment"># n 可為 0 或正整數，代表快指標除了已經多走了一圈之外，又再多走的圈數</span></span><br><span class="line">p = x + nc</span><br></pre></td></tr></table></figure><ul><li>最後的 <code>p = x + nc</code> 代表：就算走完 x 還無法會合，只要再多走 n 圈還是會相會，而且一定還是會在 cycle 起始點會合</li></ul></li></ul></li><li><p>如影片裡所說，當快慢指標會合後，把其中一個指標放回原點，再讓兩個指標同速往前，他們的交會點就會是 cycle 起點</p></li><li><p>雖然講完之後感覺程式寫起來蠻簡單，但我一開始還是犯了個小錯誤，一開始寫法如下：</p> <figure class="highlight python"><figcaption><span>Wrong solution</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:  <span class="comment"># slow 與 fast 交會</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> slow:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        node = node.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> node:</span><br><span class="line">            <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p> 有發現錯在哪嗎？當 case 是這張圖 <img src="/images/circularlinkedlist-example.png" alt=""> 的時候，我回傳的 node 是 val 為 2 的 node 而非正確答案。問題出在我沒有考慮到一個情境：當快慢指標會合之後，那個點有可能已經是 cycle 起點了，而當這個起點又剛好是 <code>head</code> 的時候，上面的程式就會出錯</p><ul><li>我錯在假設在 fast &amp; slow 第一次相會之後，slow &amp; node 兩個指標一定要動才會相會，但當 cycle 起點也是 head 的時候，他們不一定要動就可能相會。所以要改的部分就是第 16 行之後，因為它們一定會相遇，<code>while</code> 條件可以改成 <code>while node is not slow:</code>，只要他們還沒相遇就做移動，直到相遇為止</li></ul></li></ol><figure class="highlight python"><figcaption><span>修改後的正確答案</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:  <span class="comment"># slow 與 fast 交會</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:  <span class="comment"># fast 走到底了兩個都還沒交會</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    node = head</span><br><span class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> slow:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        node = node.next</span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure><p>這邊稍微提一下 Python 的 while-else，它是別的語言比較沒有的用法，但有時候還蠻好用的。<code>else</code> 的內容會在 <code>while</code> 正常結束時被執行，也就是當 <code>while</code> 被 <code>break</code> 之後，是不會執行 <code>else</code> 內容的。所以這邊的用法就是：</p><ul><li>當 slow 與 fast 交會，就繼續往下做</li><li>當 fast 走到底了兩個都還沒交會，就是沒有 cycle，此時直接 <code>return</code></li></ul><p>如果不用 while-else，就必須在 <code>while</code> 後面寫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> fast <span class="keyword">or</span> <span class="keyword">not</span> fast.next:</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>相對來說比較沒那麼簡潔</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle-ii/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路：最直覺的作法就是從頭開始沿著 next 一直走，然後用一個 set 來存放走過的 node，如果再次走到已走過的 node 就是 cycle 起點
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="two pointers" scheme="https://blog.jamesho.website/tags/two-pointers/"/>
    
      <category term="linked list" scheme="https://blog.jamesho.website/tags/linked-list/"/>
    
      <category term="python" scheme="https://blog.jamesho.website/tags/python/"/>
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
  </entry>
  
  <entry>
    <title>Reverse Linked List</title>
    <link href="https://blog.jamesho.website/reverse-linked-list/"/>
    <id>https://blog.jamesho.website/reverse-linked-list/</id>
    <published>2023-04-13T01:04:56.000Z</published>
    <updated>2023-04-13T01:29:57.734Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/reverse-linked-list/">題目</a><br>思路</p><ol><li>因為是 linked list，我們可以使用 <code>curr</code> 當指標，沿著 linked list 的頭往後走，一邊改變 <code>curr.next</code> 的指向，而過程中必須對前一個和下一個都有所掌握，因為 <code>curr</code> 必須指向前一個，然後它本身必須換到下一個</li><li>所以我們會有三個變數：<code>previous</code>, <code>curr</code>, <code>next</code></li><li>當 <code>curr</code> 是 <code>head</code> 時，<code>previous</code> 會是 <code>None</code>，這兩個可以先設定好。目標是一直改變 <code>curr</code> 的指向，讓 <code>curr</code> 一直走到 linked list 盡頭，變成 <code>None</code> 為止，所以 <code>while</code> 條件就是 <code>當有 curr 的時候就做</code><a id="more"></a></li></ol><p>Python 3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, next=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.next = next</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: Optional[ListNode])</span> -&gt; Optional[ListNode]:</span></span><br><span class="line">    previous = <span class="literal">None</span></span><br><span class="line">    curr = head</span><br><span class="line">    <span class="keyword">while</span> curr:</span><br><span class="line">        next = curr.next</span><br><span class="line">        curr.next = previous</span><br><span class="line">        previous = curr</span><br><span class="line">        curr = next</span><br><span class="line">    <span class="keyword">return</span> previous</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/reverse-linked-list/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為是 linked list，我們可以使用 &lt;code&gt;curr&lt;/code&gt; 當指標，沿著 linked list 的頭往後走，一邊改變 &lt;code&gt;curr.next&lt;/code&gt; 的指向，而過程中必須對前一個和下一個都有所掌握，因為 &lt;code&gt;curr&lt;/code&gt; 必須指向前一個，然後它本身必須換到下一個&lt;/li&gt;
&lt;li&gt;所以我們會有三個變數：&lt;code&gt;previous&lt;/code&gt;, &lt;code&gt;curr&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;當 &lt;code&gt;curr&lt;/code&gt; 是 &lt;code&gt;head&lt;/code&gt; 時，&lt;code&gt;previous&lt;/code&gt; 會是 &lt;code&gt;None&lt;/code&gt;，這兩個可以先設定好。目標是一直改變 &lt;code&gt;curr&lt;/code&gt; 的指向，讓 &lt;code&gt;curr&lt;/code&gt; 一直走到 linked list 盡頭，變成 &lt;code&gt;None&lt;/code&gt; 為止，所以 &lt;code&gt;while&lt;/code&gt; 條件就是 &lt;code&gt;當有 curr 的時候就做&lt;/code&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="linked list" scheme="https://blog.jamesho.website/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Isomorphic Strings</title>
    <link href="https://blog.jamesho.website/isomorphic-strings/"/>
    <id>https://blog.jamesho.website/isomorphic-strings/</id>
    <published>2023-04-12T08:29:09.000Z</published>
    <updated>2023-04-12T10:25:24.812Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/isomorphic-strings/">題目</a><br>這題看似不難，但第一次的做法錯了，第一次的程式碼如下，想法是用 mapping 組一個新字串 <code>t2</code>，假如跟 <code>t</code> 相同就 return True</p><p>Python 3 wrong solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        d[s[i]] = t[i]</span><br><span class="line">    t2 = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        t2 += d[c]</span><br><span class="line">    <span class="keyword">return</span> t == t2</span><br></pre></td></tr></table></figure><a id="more"></a><p>測出錯誤的 input:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"badc"</span></span><br><span class="line">t = <span class="string">"baba"</span></span><br></pre></td></tr></table></figure><p>錯誤點在於沒有檢查這個條件：<code>No two characters may map to the same character</code></p><p>檢討如下：</p><ul><li>寫完要 run 之前應該最後 check 一次是否有滿足題目提到的所有條件</li><li>以這題來說，比較好的做法是一個個 check 每個 character<ul><li>這樣只需跑一次 for-loop，不需要再跑第二次組一個新字串</li><li>每個 character 都 check 就不會漏掉上面那個條件</li></ul></li></ul><h3 id="修正解法如下"><a href="#修正解法如下" class="headerlink" title="修正解法如下"></a>修正解法如下</h3><p>Python 3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isIsomorphic</span><span class="params">(self, s: str, t: str)</span> -&gt; bool:</span></span><br><span class="line">    mapping = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        <span class="keyword">if</span> s[i] <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">            <span class="keyword">if</span> t[i] <span class="keyword">in</span> mapping.values():  <span class="comment"># 一個 t 字母同時對應到兩個 s 字母</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            mapping[s[i]] = t[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mapping[s[i]] != t[i]:  <span class="comment"># 一個 s 字母同時對應到兩個 t 字母</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/isomorphic-strings/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;這題看似不難，但第一次的做法錯了，第一次的程式碼如下，想法是用 mapping 組一個新字串 &lt;code&gt;t2&lt;/code&gt;，假如跟 &lt;code&gt;t&lt;/code&gt; 相同就 return True&lt;/p&gt;
&lt;p&gt;Python 3 wrong solution:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isIsomorphic&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, s: str, t: str)&lt;/span&gt; -&amp;gt; bool:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    d = &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; range(len(s)):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        d[s[i]] = t[i]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    t2 = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; c &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; s:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        t2 += d[c]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; t == t2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="hash table" scheme="https://blog.jamesho.website/tags/hash-table/"/>
    
      <category term="string" scheme="https://blog.jamesho.website/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>Binary Number with Alternating Bits</title>
    <link href="https://blog.jamesho.website/binary-number-with-alternating-bits/"/>
    <id>https://blog.jamesho.website/binary-number-with-alternating-bits/</id>
    <published>2023-04-12T05:26:05.000Z</published>
    <updated>2023-04-12T05:35:29.233Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-number-with-alternating-bits/">題目</a></p><ol><li>先想到的是有沒有辦法透過 bitwise operation 來判斷，發現無法</li><li>看相鄰位置有沒有一樣的，最直覺就是用字串來判斷 =&gt; 可以利用 Python 的 built-in function <code>bin</code> 來把數字轉為 binary 字串</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasAlternatingBits</span><span class="params">(self, n: int)</span> -&gt; bool:</span></span><br><span class="line">    b_str = bin(n)[<span class="number">2</span>:]  <span class="comment"># 去掉前面的 '0b'</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(b_str) - <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> b_str[i] == b_str[i + <span class="number">1</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-number-with-alternating-bits/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先想到的是有沒有辦法透過 bitwise operation 來判斷，發現無法&lt;
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="bit manipulation" scheme="https://blog.jamesho.website/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Single Number</title>
    <link href="https://blog.jamesho.website/single-number/"/>
    <id>https://blog.jamesho.website/single-number/</id>
    <published>2023-04-12T04:10:25.000Z</published>
    <updated>2023-04-12T04:32:34.486Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/single-number/">題目</a></p><ol><li>因為只能用常數的額外空間，且 array 裡的數字除了目標之外都會有<strong>兩</strong>個，所以朝 bitwise operation 的方向想</li><li>把 array 裡所有數字接連做 bitwise operation，假如有兩個一樣的數字，他們就會抵銷變為 0，即使不是連著做也一樣，所以最後的結果就是那個落單的數字<ul><li>可以想像所有數字都用二進位表示由上而下列在一起做計算，不管他們位置怎麼換結果都會一樣 (偶數個 <code>1</code> 會互相抵銷)</li></ul></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        r ^= i</span><br><span class="line">    <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因為只能用常數的額外空間，且 array 裡的數字除了目標之外都會有&lt;strong&gt;兩&lt;/strong&gt;個，所以朝 bitw
      
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="array" scheme="https://blog.jamesho.website/tags/array/"/>
    
      <category term="bit manipulation" scheme="https://blog.jamesho.website/tags/bit-manipulation/"/>
    
  </entry>
  
  <entry>
    <title>Validate Binary Search Tree</title>
    <link href="https://blog.jamesho.website/validate-binary-search-tree/"/>
    <id>https://blog.jamesho.website/validate-binary-search-tree/</id>
    <published>2023-04-12T01:11:56.000Z</published>
    <updated>2023-04-12T03:12:38.007Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/validate-binary-search-tree/">題目</a><br>思路</p><ol><li>樹的問題用遞迴來解相對上比較直覺，所以先試試遞迴解</li><li>拆解到最小單位來找 recursive case: 隨機取樹中一個點，判斷它是否 valid</li><li>大部分情況下會有上限和下限。以左邊的點為例，上限就是父節點的值，下限就是它所在的右子樹的父節點的值，所以這個值必須由上到下一層層傳遞下來。反之，右邊的點的話，就變成上限必須一層層傳遞下來</li><li>因為上下限必須用傳遞的，所以寫一個 function <code>node_valid</code> 接受上下限的參數<a id="more"></a>Python3 solution:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_valid</span><span class="params">(node, floor=float<span class="params">(<span class="string">'-inf'</span>)</span>, ceiling=float<span class="params">(<span class="string">'inf'</span>)</span>)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        v = node.val</span><br><span class="line">        <span class="keyword">if</span> v &lt;= floor <span class="keyword">or</span> v &gt;= ceiling:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node_valid(node.left, floor, v):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node_valid(node.right, v, ceiling):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> node_valid(root)</span><br></pre></td></tr></table></figure><p>假設樹有 n 個 node</p><ul><li>時間複雜度：O(n)<ul><li>因為每個點都會做一次，而每次的複雜度為 O(1)</li><li><a name="time-complexity-example"></a>另一個算法可參考<a href="/2023/03/21/recursion-time-complexity">這邊</a>的快速解：<ul><li><code>node_valid</code> 的遞迴深度為這棵樹的深度 (兩次呼叫自己的深度的相加)，在樹為平衡的情況下，深度為 log2 n，所以複雜度為 O(2^(log2 n)) = O(n)</li></ul></li></ul></li></ul><h3 id="接下來嘗試用迭代解"><a href="#接下來嘗試用迭代解" class="headerlink" title="接下來嘗試用迭代解"></a>接下來嘗試用迭代解</h3><ol><li>可以用跟遞迴類似的思路，只是改成把要處理的 nodes 都放到 stack 裡，然後每次迴圈都從裡面拿一個出來做，一直做到 stack 為空。迴圈裡的內容就是 recursive case</li><li>因為 floor 和 ceiling 必須一直傳下去，所以跟 node 一起包成 tuple 放入 stack</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    stack = [(root, float(<span class="string">'-inf'</span>), float(<span class="string">'inf'</span>))]  <span class="comment"># node, floor, ceiling</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        node, floor, ceiling = stack.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        v = node.val</span><br><span class="line">        <span class="keyword">if</span> v &lt;= floor <span class="keyword">or</span> v &gt;= ceiling:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        stack.extend([</span><br><span class="line">            (node.left, floor, v),</span><br><span class="line">            (node.right, v, ceiling)</span><br><span class="line">        ])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/validate-binary-search-tree/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;樹的問題用遞迴來解相對上比較直覺，所以先試試遞迴解&lt;/li&gt;
&lt;li&gt;拆解到最小單位來找 recursive case: 隨機取樹中一個點，判斷它是否 valid&lt;/li&gt;
&lt;li&gt;大部分情況下會有上限和下限。以左邊的點為例，上限就是父節點的值，下限就是它所在的右子樹的父節點的值，所以這個值必須由上到下一層層傳遞下來。反之，右邊的點的話，就變成上限必須一層層傳遞下來&lt;/li&gt;
&lt;li&gt;因為上下限必須用傳遞的，所以寫一個 function &lt;code&gt;node_valid&lt;/code&gt; 接受上下限的參數
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="binary search tree" scheme="https://blog.jamesho.website/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>使用 Dokku 將 Web App 部署在 DigitalOcean</title>
    <link href="https://blog.jamesho.website/use-dokku-on-digitalocean/"/>
    <id>https://blog.jamesho.website/use-dokku-on-digitalocean/</id>
    <published>2023-04-05T07:37:28.000Z</published>
    <updated>2023-04-05T10:20:02.280Z</updated>
    
    <content type="html"><![CDATA[<p>因為 Heroku 現在要收費了，原本放在上面<a href="https://github.com/james687/Tweetme">用免費方案的 project</a> 就需要找新的方法。於是找到了 <a href="https://github.com/dokku/dokku">Dokku</a>，他的 GitHub page 介紹如下：</p><blockquote><p>Docker powered mini-Heroku. The smallest PaaS implementation you’ve ever seen.</p></blockquote><p>的確是很傳神，因為使用方法跟 Heroku 很像，基本上可以從 Heroku 無痛遷移，差別在你需要用自己的 VM &amp; domain，配合 dokku 就可以在上面用 docker 管理你的 application，就像他的 about 寫的：<a id="more"></a></p><blockquote><p>A docker-powered PaaS that helps you build and manage the lifecycle of applications</p></blockquote><p>這邊使用 DigitalOcean 的 droplet，因為他有兩個月 200 美金的試用 credits，假如只是短期測試專案的話也夠了，不然也可以兩個月換一個新帳號 😅</p><p>這邊稍微筆記一下把 Heroku 專案搬過來的過程：</p><ul><li>在 DigitalOcean 創一個 droplet, 在上面照著<a href="https://dokku.com/docs/getting-started/installation/">文件</a>的步驟做，droplet OS 需選擇 dokku 支援的版本</li><li>使用 subdomain 的步驟：<ol><li><code>dokku domains:set-global {domain}</code></li><li><code>dokku domains:set {dokku_app_name} {subdomain.domain}</code></li><li>設定 domain 的 A record, CNAME<ul><li>A record: <ul><li>Host: <code>@</code></li><li>Value: droplet IP</li></ul></li><li>CNAME<ul><li>Host: subdomain</li><li>Value: <code>{domain}.</code></li></ul></li></ul></li></ol><ul><li>看起來這個方法應該可以讓我們在同一個 droplet 裡，用不同的 subdomains 跑多個不同的 web apps。只要分別設定多個 CNAME 和對應的 dokku app domain 就好<ul><li>流程：{subdomain_a.domain} 的 request 依循 IP 到了該 droplet 的 nginx，nginx 再將 request 導到 subdomain_a 對應的 dokku app</li></ul></li><li>如果單純只想讓 <code>{dokku_app_name}.{domain}</code> 指到 dokku app，也可以只設定 A record:<ul><li>Host: <code>dokku_app_name</code></li><li>Value: droplet IP</li></ul></li></ul></li><li><code>dokku config:set {dokku_app_name} KEY=value</code> 可設定需要的環境變數</li><li>可以用 runtime.txt 指定 python 執行的版本</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因為 Heroku 現在要收費了，原本放在上面&lt;a href=&quot;https://github.com/james687/Tweetme&quot;&gt;用免費方案的 project&lt;/a&gt; 就需要找新的方法。於是找到了 &lt;a href=&quot;https://github.com/dokku/dokku&quot;&gt;Dokku&lt;/a&gt;，他的 GitHub page 介紹如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Docker powered mini-Heroku. The smallest PaaS implementation you’ve ever seen.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;的確是很傳神，因為使用方法跟 Heroku 很像，基本上可以從 Heroku 無痛遷移，差別在你需要用自己的 VM &amp;amp; domain，配合 dokku 就可以在上面用 docker 管理你的 application，就像他的 about 寫的：
    
    </summary>
    
    
      <category term="Development Note" scheme="https://blog.jamesho.website/categories/Development-Note/"/>
    
    
      <category term="docker" scheme="https://blog.jamesho.website/tags/docker/"/>
    
      <category term="heroku" scheme="https://blog.jamesho.website/tags/heroku/"/>
    
      <category term="dokku" scheme="https://blog.jamesho.website/tags/dokku/"/>
    
      <category term="paas" scheme="https://blog.jamesho.website/tags/paas/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Level Order Traversal</title>
    <link href="https://blog.jamesho.website/binary-tree-level-order-traversal/"/>
    <id>https://blog.jamesho.website/binary-tree-level-order-traversal/</id>
    <published>2023-03-28T11:25:25.000Z</published>
    <updated>2023-03-30T04:45:41.803Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/">題目</a><br>思路</p><ol><li>一次一層很直覺想到廣先搜尋 (BFS)，所以用 iterative 的做法來解</li><li>一次迴圈處理一層，並把下一層節點放入 stack 繼續在下次迴圈處理<ul><li>stack 也是 list of list, 裡面的每個 list 都是一層節點<a id="more"></a></li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    stack, values = [[root]], []</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        level_vals = []</span><br><span class="line">        level_nodes = []</span><br><span class="line">        nodes = stack.pop()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> nodes:</span><br><span class="line">            level_vals.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                level_nodes.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                level_nodes.append(node.right)</span><br><span class="line">        <span class="keyword">if</span> level_nodes:</span><br><span class="line">            stack.append(level_nodes)</span><br><span class="line">        values.append(level_vals)</span><br><span class="line">    <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="但假如用遞迴的話怎麼解？"><a href="#但假如用遞迴的話怎麼解？" class="headerlink" title="但假如用遞迴的話怎麼解？"></a>但假如用遞迴的話怎麼解？</h3><p>Recursive case: 把當下這個節點的 value 放到對應 level index 的 list 中</p><ul><li><p>如果沒有對應的 level index 就加一個空 list 進去 (<code>level_ind</code> 會從 0 開始依序傳入，不會有跳號的情況)</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    level = res[level_ind]</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    level = []</span><br><span class="line">    res.append(level)</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put_value</span><span class="params">(node, level_ind, res)</span>:</span></span><br><span class="line">        <span class="comment"># Base case</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Recursive case</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            level = res[level_ind]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            level = []</span><br><span class="line">            res.append(level)</span><br><span class="line">        level.append(node.val)</span><br><span class="line">        put_value(node.left, level_ind + <span class="number">1</span>, res)</span><br><span class="line">        put_value(node.right, level_ind + <span class="number">1</span>, res)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    res = []</span><br><span class="line">    put_value(root, <span class="number">0</span>, res)</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一次一層很直覺想到廣先搜尋 (BFS)，所以用 iterative 的做法來解&lt;/li&gt;
&lt;li&gt;一次迴圈處理一層，並把下一層節點放入 stack 繼續在下次迴圈處理&lt;ul&gt;
&lt;li&gt;stack 也是 list of list, 裡面的每個 list 都是一層節點
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="breadth-first search" scheme="https://blog.jamesho.website/tags/breadth-first-search/"/>
    
  </entry>
  
  <entry>
    <title>Binary Tree Inorder Traversal</title>
    <link href="https://blog.jamesho.website/binary-tree-inorder-traversal/"/>
    <id>https://blog.jamesho.website/binary-tree-inorder-traversal/</id>
    <published>2023-03-23T08:51:55.000Z</published>
    <updated>2023-03-30T04:47:05.770Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">題目</a><br>思路</p><ol><li>Inorder Traversal: 對任意節點來說，順序為 左子樹 -&gt; 自己 -&gt; 右子樹</li><li>可拆解為最小單位動作，即第一點，故使用遞迴<a id="more"></a></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""@return node values with inorder-traversal order"""</span></span><br><span class="line">        <span class="comment"># Base case</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Recursive case</span></span><br><span class="line">        values = self.inorderTraversal(root.left)  <span class="comment"># 先取得左子節點所有的 inorder-traversal values</span></span><br><span class="line">        values.append(root.val)</span><br><span class="line">        values.extend(self.inorderTraversal(root.right))  <span class="comment"># 最後加上右子節點的所有 inorder-traversal values</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> values</span><br></pre></td></tr></table></figure><h3 id="這個題目使用遞迴是相對直觀的，以下改用-iterative-的方式來解："><a href="#這個題目使用遞迴是相對直觀的，以下改用-iterative-的方式來解：" class="headerlink" title="這個題目使用遞迴是相對直觀的，以下改用 iterative 的方式來解："></a>這個題目使用遞迴是相對直觀的，以下改用 iterative 的方式來解：</h3><p>思路：使用一個 list 當 stack 來放 nodes，只要<strong>按照順序</strong>放入，再從裡面依序把 node <code>pop()</code> 出來取 value，stack 為空的時候代表已處理完所有的 nodes =&gt; 回傳答案。以下列出主要分解動作：</p><ol><li><p>把 root 和 root 所有的左節點由上到下依序放入 stack，放完後 stack 裡自然會包含左節點跟中間的節點</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> root:</span><br><span class="line">    stack.append(root)</span><br><span class="line">    root = root.left</span><br></pre></td></tr></table></figure></li><li><p>把 node <code>pop()</code> 出來取 value，此時最先被 pop 出來的會是最下面的左節點。可以先參照接下來的程式碼，當 node 為葉子節點時，不會有 <code>node.right</code>，所以下一個迴圈會繼續 pop 出中間的節點</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node = stack.pop()</span><br><span class="line">values.append(node.val)</span><br></pre></td></tr></table></figure></li><li><p>左、中節點處理完後，處理右節點：把右節點當成新的 root，重複前兩步驟</p><ol><li><code>root = node.right</code></li><li>上面一行連同前兩步驟的程式碼 (如下)，用 <code>while True:</code> 包起來</li></ol></li><li><p>寫終止條件：在 <code>node = stack.pop()</code> 之前判斷 stack 是否還有，如為空代表所有的節點已被遍歷完，故回傳答案 <code>values</code></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="string">"""@return node values with inorder-traversal order"""</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        stack, values = [], []</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">while</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                <span class="keyword">return</span> values</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            values.append(node.val)</span><br><span class="line">            root = node.right</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/binary-tree-inorder-traversal/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Inorder Traversal: 對任意節點來說，順序為 左子樹 -&amp;gt; 自己 -&amp;gt; 右子樹&lt;/li&gt;
&lt;li&gt;可拆解為最小單位動作，即第一點，故使用遞迴
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>House Robber II</title>
    <link href="https://blog.jamesho.website/house-robber-ii/"/>
    <id>https://blog.jamesho.website/house-robber-ii/</id>
    <published>2023-03-23T05:37:15.000Z</published>
    <updated>2023-03-30T04:47:22.940Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/house-robber-ii/">題目</a><br>思路</p><ol><li>跟 <a href="https://leetcode.com/problems/house-robber">House Robber</a> 很像，只差在房子的排列變成頭尾相連，有沒有辦法把這題拆解，變成能用上第一版 House Robber 的解題方法？譬如把環形變回直排？</li><li>變成環形之後多出來的限制讓我們可以把這題分成以下三種情況：<ol><li>搶第一個、不搶最後一個：加入第三種情況，等同於可以<strong>視為直排，但只考慮到倒數第二個</strong></li><li>不搶第一個、搶最後一個：加入第三種情況，等同於可以<strong>視為直排，但從第二個開始考慮</strong><a id="more"></a></li><li>第一個和最後一個都不搶：可與前兩種情況合併</li></ol><ul><li>最後把以上三種情況合併為粗體的兩種情況，<strong>轉為第一版 House Robber 問題</strong>，接下來只需取兩種情況錢比較多的就是答案</li></ul></li><li>因為現在需多考慮起始 index，我們把<a href="https://james687.github.io/2023/03/20/house-robber">第一版解法</a>的遞迴函式改為多傳入起始 index，並同樣用 <code>@cache</code> 避免同樣的 <code>inner_rob(i, j)</code> 重複計算<ul><li>Base case 寫法：<ol><li>考慮一開始 <code>j</code> 比 <code>i</code> 大的情況，一路因為 <code>inner_rob(i, j - 1)</code>, <code>inner_rob(i, j - 2)</code> 而減少的情況：<ol><li><code>j == i + 2</code> 時：下兩個遞迴節點為 <code>inner_rob(i, i + 1)</code>, <code>inner_rob(i, i)</code></li><li><code>j == i + 1</code> 時： 下兩個遞迴節點為 <code>inner_rob(i, i)</code>, <code>inner_rob(i, i - 1)</code></li></ol><ul><li>此時可以寫出 base case 的兩種情況 <code>j == i</code>, <code>j &lt; i</code>，寫完後將 <code>inner_rob(i, j)</code> 代入 <code>j == i + 1</code> 驗算看看是否正確</li></ul></li><li>考慮一開始 <code>j == i</code> 的情況，代入驗算看看是否正確</li><li>考慮一開始 <code>j &lt; i</code> 的情況，也就是 <code>len(nums) == 1</code> 時：<ul><li>此時得出的答案為 <code>0</code>，是錯的，所以 base case 需多考慮這種情況，加入 <code>len(nums) == 1</code> 時的判斷處理</li></ul></li></ol></li></ul></li><li>取錢比較多的情況即為答案：<code>return max(inner_rob(0, len(nums) - 2), inner_rob(1, len(nums) - 1))</code></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="meta">    @cache</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_rob</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="string">"""@return 由 index i 搶到 j 可得的最大收穫"""</span></span><br><span class="line">        <span class="comment"># Base case</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> j == i:</span><br><span class="line">            <span class="keyword">return</span> nums[j]</span><br><span class="line">        <span class="keyword">if</span> j &lt; i:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment"># Recursive case</span></span><br><span class="line">        <span class="keyword">return</span> max(inner_rob(i, j - <span class="number">1</span>), nums[j] + inner_rob(i, j - <span class="number">2</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> max(inner_rob(<span class="number">0</span>, len(nums) - <span class="number">2</span>), inner_rob(<span class="number">1</span>, len(nums) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>如果不用 <code>@cache</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    l = len(nums)</span><br><span class="line">    memo = [[<span class="literal">None</span>] * l <span class="keyword">for</span> _ <span class="keyword">in</span> range(l)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_rob</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="string">"""@return 由 index i 搶到 j 可得的最大收穫"""</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> i == j:</span><br><span class="line">            <span class="keyword">return</span> nums[j]</span><br><span class="line">        <span class="keyword">if</span> j &lt; i:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> memo[i][j] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[i][j]</span><br><span class="line">        memo[i][j] = max(inner_rob(i, j - <span class="number">1</span>), nums[j] + inner_rob(i, j - <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> memo[i][j]</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> max(inner_rob(<span class="number">0</span>, len(nums) - <span class="number">2</span>), inner_rob(<span class="number">1</span>, len(nums) - <span class="number">1</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber-ii/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跟 &lt;a href=&quot;https://leetcode.com/problems/house-robber&quot;&gt;House Robber&lt;/a&gt; 很像，只差在房子的排列變成頭尾相連，有沒有辦法把這題拆解，變成能用上第一版 House Robber 的解題方法？譬如把環形變回直排？&lt;/li&gt;
&lt;li&gt;變成環形之後多出來的限制讓我們可以把這題分成以下三種情況：&lt;ol&gt;
&lt;li&gt;搶第一個、不搶最後一個：加入第三種情況，等同於可以&lt;strong&gt;視為直排，但只考慮到倒數第二個&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不搶第一個、搶最後一個：加入第三種情況，等同於可以&lt;strong&gt;視為直排，但從第二個開始考慮&lt;/strong&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="dynamic programming" scheme="https://blog.jamesho.website/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>遞迴的時間複雜度算法</title>
    <link href="https://blog.jamesho.website/recursion-time-complexity/"/>
    <id>https://blog.jamesho.website/recursion-time-complexity/</id>
    <published>2023-03-21T08:55:19.000Z</published>
    <updated>2023-04-12T03:05:32.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速解-適用於遞迴函式內呼叫自己-gt-1-次"><a href="#快速解-適用於遞迴函式內呼叫自己-gt-1-次" class="headerlink" title="快速解 (適用於遞迴函式內呼叫自己 &gt; 1 次)"></a>快速解 (適用於遞迴函式內呼叫自己 &gt; 1 次)</h3><ol><li>看這個遞迴函式呼叫自己幾次，假設呼叫了 <code>x</code> 次</li><li>看看那些遞迴呼叫的深度。假如函式內呼叫自己兩次，深度各為 m、n，此時這個遞迴函式的總深度 <code>h = m + n</code></li><li>時間複雜度為 <code>O(x^h)</code></li></ol><ul><li>至少目前套用在幾個比較單純的遞迴式都成立，不確定複雜的是不是也成立<a id="more"></a></li><li>例子：<a href="/2023/04/12/validate-binary-search-tree#time-complexity-example">Validate Binary Search Tree</a></li></ul><h3 id="詳細解-遞迴樹"><a href="#詳細解-遞迴樹" class="headerlink" title="詳細解 (遞迴樹)"></a>詳細解 (遞迴樹)</h3><p>以 <a href="https://james687.github.io/2023/03/18/unique-paths/">Unique Paths</a> 的遞迴解為例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">u_paths</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> u_paths(i + <span class="number">1</span>, j) + u_paths(i, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> u_paths(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ol><li>假設 <code>m = 3, n = 2</code>，遞迴樹如下 <img src="/images/recursion-tree.png" alt=""></li><li>由圖可知，遞迴深度為 <code>5 (= m + n)</code><ul><li>要怎麼不用畫圖，用看的就得出深度？<ul><li>深度為根節點走到葉子節點的路徑長，我們可以看從 <code>u_paths(0, 0)</code> 開始，要走幾次才會結束：<ol><li><code>u_paths(i + 1, j)</code> 這邊只需要看 <code>i</code>，要走 <code>i + 1 = 1, 2, ..., m</code> 共 <code>m</code> 次</li><li>走完 <code>m</code> 次之後還有 <code>u_paths(i, j + 1)</code>，要接著再走 <code>j + 1 = 1, 2, ..., n</code> 共 <code>n</code> 次</li><li>所以需要走 <code>m + n</code> 次才會結束</li></ol></li></ul></li></ul></li><li><code>u_paths</code> 合併遞迴結果的運算只需要一次加法，可以把時間消耗記做 <code>1</code>，也就是每個節點的時間消耗都是 <code>1</code></li><li>所有節點的時間消耗總合就是這個函式的時間複雜度。第一層有 <code>1 (= 2^0)</code> 個節點，第二層有 <code>2 (= 2^1)</code> 個節點，第三層有 <code>4 (= 2^2)</code> 個節點，以此類推，假設此樹深度為 <code>h</code>，所有節點的時間消耗和為 <code>2^0 + 2^1 + 2^2 + ... + 2^h</code>，依據等比級數和的公式得出結果為 <code>2^(h + 1) - 1</code><ul><li>這邊的算法是假設這是一個滿二元樹來算，但其實這並不是一個滿二元樹 (像第四層就只有 <code>7</code> 個節點)，所以遞迴樹法並不嚴謹，只是一個估算，真要嚴謹分析的話可以再用 Substitution Method 或 Master Theorem 來驗證</li><li>由第二點，深度 <code>h = m + n</code></li></ul></li><li>所以時間複雜度為 <code>O(2^(h + 1)) = O(2 * 2^h) = O(2^h) = O(2^(m + n))</code></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;快速解-適用於遞迴函式內呼叫自己-gt-1-次&quot;&gt;&lt;a href=&quot;#快速解-適用於遞迴函式內呼叫自己-gt-1-次&quot; class=&quot;headerlink&quot; title=&quot;快速解 (適用於遞迴函式內呼叫自己 &amp;gt; 1 次)&quot;&gt;&lt;/a&gt;快速解 (適用於遞迴函式內呼叫自己 &amp;gt; 1 次)&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;看這個遞迴函式呼叫自己幾次，假設呼叫了 &lt;code&gt;x&lt;/code&gt; 次&lt;/li&gt;
&lt;li&gt;看看那些遞迴呼叫的深度。假如函式內呼叫自己兩次，深度各為 m、n，此時這個遞迴函式的總深度 &lt;code&gt;h = m + n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;時間複雜度為 &lt;code&gt;O(x^h)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;至少目前套用在幾個比較單純的遞迴式都成立，不確定複雜的是不是也成立
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://blog.jamesho.website/categories/Algorithm/"/>
    
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
  </entry>
  
  <entry>
    <title>House Robber</title>
    <link href="https://blog.jamesho.website/house-robber/"/>
    <id>https://blog.jamesho.website/house-robber/</id>
    <published>2023-03-20T07:08:15.000Z</published>
    <updated>2023-03-30T04:47:34.521Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/house-robber/">題目</a><br>思路</p><ol><li>可以把得出答案的過程拆解為最小可重複步驟，用遞迴來解</li><li>Recursive case: 假設 index 為 i，由 index 0 搶到 i 可得的最大收穫為 <code>inner_rob(i)</code>。在位置 i, 可選擇搶或不搶：<ol><li>不搶：最大收穫跟前一個點一樣，為 <code>inner_rob(i - 1)</code></li><li>搶：代表前一個點一定是不搶，所以最大收穫為這個點的 money <code>nums[i]</code> 再加上前前個點的最大收穫 <code>inner_rob(i - 2)</code></li></ol><ul><li>所以 <code>inner_rob(i)</code> 為以上兩種情況取較大的那個<a id="more"></a></li></ul></li><li>Base case (終止條件)：<code>i &lt; 0</code></li><li>因為這個<a href="https://james687.github.io/2023/03/21/recursion-time-complexity/">遞迴解的時間複雜度</a>最差為 O(2^n)，必須降低，我們可以把計算過的 <code>inner_rob(i)</code> 使用 <code>@cache</code> 將 function 回傳 cache 起來，避免同樣的 <code>inner_rob(i)</code> 重複計算</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line"><span class="meta">    @cache</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_rob</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="string">"""@return 由 index 0 搶到 i 可得的最大收穫"""</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(inner_rob(i - <span class="number">1</span>), nums[i] + inner_rob(i - <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> inner_rob(len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：O(n)<ul><li>因為有記憶，每個點只會計算一次，共有 n 個點</li></ul></li><li>空間複雜度：O(n)<ul><li>cache 需要的空間為 n，遞迴的最大深度也是 n</li></ul></li></ul><p>以上，如果不用 <code>@cache</code> 的話：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    memo = [<span class="literal">None</span>] * len(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner_rob</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> memo[i] <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[i]</span><br><span class="line">        memo[i] = max(inner_rob(i - <span class="number">1</span>), nums[i] + inner_rob(i - <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> memo[i]</span><br><span class="line">    <span class="keyword">return</span> inner_rob(len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/house-robber/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以把得出答案的過程拆解為最小可重複步驟，用遞迴來解&lt;/li&gt;
&lt;li&gt;Recursive case: 假設 index 為 i，由 index 0 搶到 i 可得的最大收穫為 &lt;code&gt;inner_rob(i)&lt;/code&gt;。在位置 i, 可選擇搶或不搶：&lt;ol&gt;
&lt;li&gt;不搶：最大收穫跟前一個點一樣，為 &lt;code&gt;inner_rob(i - 1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;搶：代表前一個點一定是不搶，所以最大收穫為這個點的 money &lt;code&gt;nums[i]&lt;/code&gt; 再加上前前個點的最大收穫 &lt;code&gt;inner_rob(i - 2)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;所以 &lt;code&gt;inner_rob(i)&lt;/code&gt; 為以上兩種情況取較大的那個
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="dynamic programming" scheme="https://blog.jamesho.website/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Unique Paths</title>
    <link href="https://blog.jamesho.website/unique-paths/"/>
    <id>https://blog.jamesho.website/unique-paths/</id>
    <published>2023-03-18T08:08:15.000Z</published>
    <updated>2023-03-30T04:49:45.044Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/unique-paths/description/">題目</a><br>思路</p><ol><li><p>每走一步都會是一個 unique path，到終點的路線是由每一步所組成的，所以可以用遞迴的方式來想，最小的可重複動作就是一步，點 (i, j) 到終點的 unique path count 就是 (i + 1, j) 和 (i, j + 1) 的 unique path count 的和</p></li><li><p>最小可重複動作 <code>return u_paths(i + 1, j) + u_paths(i, j + 1)</code></p><a id="more"></a></li><li><p>終止條件</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>已經在終點上了，unique path count 卻是 1，一開始可能會覺得有點怪，不過從終點左邊那個點來想，就不會怪了：<ul><li>左邊那個點的 unique path count = (它的下面那點的 path count) + (它右邊那點的 path count)<ul><li>下面那點：path count 為 0</li><li>右邊那點 (終點)：path count 必須是 1</li></ul></li></ul></li></ul></li><li><p>遞迴解法如下，但時間複雜度 O(2^(m + n)) 太大了 (計算參考<a href="https://james687.github.io/2023/03/21/recursion-time-complexity/">這篇</a>)</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">u_paths</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        i, j 為從 0 開始的坐標</span></span><br><span class="line"><span class="string">        @return 由 (i, j) 走到終點的 unique path count</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 終止條件</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最小可重複動作</span></span><br><span class="line">        <span class="keyword">return</span> u_paths(i + <span class="number">1</span>, j) + u_paths(i, j + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> u_paths(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>因為同一個點可能會走到很多次，我們可以把結果存在二維陣列，避免重複計算，以減少時間複雜度</p></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    dp = [[<span class="literal">None</span>] * n <span class="keyword">for</span> i <span class="keyword">in</span> range(m)]  <span class="comment"># m * n 的二維陣列</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">u_paths</span><span class="params">(i, j)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        i, j 為從 0 開始的坐標</span></span><br><span class="line"><span class="string">        @return 由 (i, j) 走到終點的 unique path count</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># 終止條件</span></span><br><span class="line">        <span class="keyword">if</span> i &gt;= m <span class="keyword">or</span> j &gt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> i == m - <span class="number">1</span> <span class="keyword">and</span> j == n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">            <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 最小可重複動作</span></span><br><span class="line">        dp[i][j] = u_paths(i + <span class="number">1</span>, j) + u_paths(i, j + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> dp[i][j]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> u_paths(<span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><ul><li>時間複雜度：O(m * n)<ul><li>因為有記憶，每個點只會計算一次，共有 <code>m * n</code> 個點</li></ul></li><li>空間複雜度：O(m * n)<ul><li>維護 <code>dp</code> 所需空間。遞迴呼叫所需空間 <code>m</code> 和 <code>n</code> 可忽略</li></ul></li></ul><p>類似題：</p><ul><li><a href="https://leetcode.com/problems/fibonacci-number">Fibonacci Number</a></li><li><a href="https://leetcode.com/problems/unique-paths-ii">Unique Paths II</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/unique-paths/description/&quot;&gt;題目&lt;/a&gt;&lt;br&gt;思路&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;每走一步都會是一個 unique path，到終點的路線是由每一步所組成的，所以可以用遞迴的方式來想，最小的可重複動作就是一步，點 (i, j) 到終點的 unique path count 就是 (i + 1, j) 和 (i, j + 1) 的 unique path count 的和&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;最小可重複動作 &lt;code&gt;return u_paths(i + 1, j) + u_paths(i, j + 1)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="dynamic programming" scheme="https://blog.jamesho.website/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>Merge Two Binary Trees</title>
    <link href="https://blog.jamesho.website/merge-two-binary-trees/"/>
    <id>https://blog.jamesho.website/merge-two-binary-trees/</id>
    <published>2023-03-16T03:27:23.000Z</published>
    <updated>2023-03-30T04:48:03.303Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/merge-two-binary-trees/description/">題目</a></p><h3 id="做法一：recursive-DFS"><a href="#做法一：recursive-DFS" class="headerlink" title="做法一：recursive - DFS"></a>做法一：recursive - DFS</h3><ol><li><p>找出最小的可重複動作：merge 兩個 nodes</p><ul><li>題目給的 method 就可以用來做遞迴</li></ul></li><li><p>假設 <code>mergeTrees</code> 已完成，實作此最小可重複動作</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root1.val += root2.val</span><br><span class="line">root1.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">root1.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line"><span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><a id="more"></a></li><li><p>寫出遞迴的終止條件</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line">    <span class="keyword">return</span> root1 <span class="keyword">or</span> root2</span><br></pre></td></tr></table></figure></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, root1: Optional[TreeNode], root2: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line">        <span class="keyword">return</span> root1 <span class="keyword">or</span> root2</span><br><span class="line">    root1.val += root2.val</span><br><span class="line">    root1.left = self.mergeTrees(root1.left, root2.left)</span><br><span class="line">    root1.right = self.mergeTrees(root1.right, root2.right)</span><br><span class="line">    <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><p>假設兩棵樹有較少節點的那顆有 n 個節點</p><ul><li>時間複雜度：O(n)</li><li>空間複雜度：n 個節點那棵樹的深度<ul><li>最差情況是 O(n), 平均為 O(log n)</li></ul></li></ul><h3 id="做法二：iterative-BFS"><a href="#做法二：iterative-BFS" class="headerlink" title="做法二：iterative - BFS"></a>做法二：iterative - BFS</h3><ol><li>準備一個 stack 來放待 merge 的 node pairs</li><li>一次從裡面拿一個 pair 出來 merge, 同時也把該 merge 的子節點 pair 丟進去。一直做到 stack 裡面沒東西為止</li><li>因為這邊是 merge 到 root1, 故最後回傳 root1<ul><li>注意不要回傳到 <code>p</code>, 而是應該回傳當初的根節點 root1</li></ul></li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span><span class="params">(self, root1: Optional[TreeNode], root2: Optional[TreeNode])</span> -&gt; Optional[TreeNode]:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root1 <span class="keyword">or</span> <span class="keyword">not</span> root2:</span><br><span class="line">        <span class="keyword">return</span> root1 <span class="keyword">or</span> root2</span><br><span class="line">    stack = [(root1, root2)]</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        p, q = stack.pop()  <span class="comment"># 使用暫時的變數 p, q 來操作節點 merge</span></span><br><span class="line">        p.val += q.val</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.left <span class="keyword">and</span> q.left:</span><br><span class="line">            p.left = q.left</span><br><span class="line">        <span class="keyword">elif</span> p.left <span class="keyword">and</span> q.left:</span><br><span class="line">            stack.append((p.left, q.left))</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p.right <span class="keyword">and</span> q.right:</span><br><span class="line">            p.right = q.right</span><br><span class="line">        <span class="keyword">elif</span> p.right <span class="keyword">and</span> q.right:</span><br><span class="line">            stack.append((p.right, q.right))</span><br><span class="line">    <span class="keyword">return</span> root1</span><br></pre></td></tr></table></figure><p>假設兩棵樹有較少節點的那顆有 n 個節點</p><ul><li>時間複雜度：O(n)<ul><li>stack 裡會有 n 個 pairs, 所以會做 n 次</li></ul></li><li>空間複雜度：O(n)<ul><li>需要大小為 n 的 stack</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/merge-two-binary-trees/description/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;做法一：recursive-DFS&quot;&gt;&lt;a href=&quot;#做法一：recursive-DFS&quot; class=&quot;headerlink&quot; title=&quot;做法一：recursive - DFS&quot;&gt;&lt;/a&gt;做法一：recursive - DFS&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找出最小的可重複動作：merge 兩個 nodes&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;題目給的 method 就可以用來做遞迴&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;假設 &lt;code&gt;mergeTrees&lt;/code&gt; 已完成，實作此最小可重複動作&lt;/p&gt;
 &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root1.val += root2.val&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root1.left = self.mergeTrees(root1.left, root2.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root1.right = self.mergeTrees(root1.right, root2.right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; root1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
      <category term="breadth-first search" scheme="https://blog.jamesho.website/tags/breadth-first-search/"/>
    
  </entry>
  
  <entry>
    <title>Balanced Binary Tree</title>
    <link href="https://blog.jamesho.website/balanced-binary-tree/"/>
    <id>https://blog.jamesho.website/balanced-binary-tree/</id>
    <published>2023-03-15T04:12:23.000Z</published>
    <updated>2023-03-30T04:46:34.670Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.com/problems/balanced-binary-tree/description/">題目</a></p><h3 id="做法一"><a href="#做法一" class="headerlink" title="做法一"></a>做法一</h3><p>思路：</p><ol><li>依照 height-balanced 的定義，需要符合<strong>每個</strong>node 的左右子樹高度差都不大於 1</li><li>假設有個 function <code>height</code> 可以回傳 node 的 height<ul><li>先不實作內容</li></ul></li><li>使用這個 <code>height</code> 完成 <code>isBalanced</code><a id="more"></a></li><li>實作 <code>height</code> 的內容</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:  <span class="comment"># 終止條件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lh = height(node.left)</span><br><span class="line">        rh = height(node.right)</span><br><span class="line">        <span class="keyword">return</span> max(lh, rh) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:  <span class="comment"># 終止條件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    lh = height(root.left)</span><br><span class="line">    rh = height(root.right)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 即使左右子樹高度差不大於一，子樹本身還是有可能是不平衡的，所以要再加上後面的 `isBalanced` 判斷</span></span><br><span class="line">    <span class="keyword">return</span> abs(lh - rh) &lt;= <span class="number">1</span> <span class="keyword">and</span> self.isBalanced(root.left) <span class="keyword">and</span> self.isBalanced(root.right)</span><br></pre></td></tr></table></figure><p>假設有 n 個 node, 樹的高度為 h</p><ul><li>時間複雜度：O(n^2)<ul><li><code>isBalanced</code> 除了呼叫自己之外的複雜度為 O(n)<ul><li>呼叫了 <code>n - 1</code> 次 <code>height</code></li></ul></li><li>每個節點都呼叫了一次 <code>isBalanced</code></li></ul></li><li>空間複雜度：O(h)<ul><li>因為遞迴的呼叫有 DFS 的特性，會從子節點一直呼叫到最下面的葉子節點，所以需要把那些 function calls 放進 stack 裡，等到葉子節點的呼叫到了再一一拿出來執行。因此 stack 的大小需等於呼叫的次數，也就是由根節點走到葉子節點需經過幾個點，即這棵樹的高度<ul><li>只需考慮一次遞迴呼叫所需空間，不需考慮全部遞迴呼叫 (譬如在 function 裡呼叫了自己兩次)，因為程式同時只會處理一個遞迴呼叫</li></ul></li></ul></li></ul><h3 id="做法二"><a href="#做法二" class="headerlink" title="做法二"></a>做法二</h3><p>思路：</p><ol><li>有沒有辦法優化上面做法的時間複雜度呢？因為上面在算高度的時候就已經會算出每個節點的左右子樹的高度了，此時就可以順便看看是否平衡，不用等到最後再遞迴呼叫 <code>isBalanced</code> 增加複雜度</li></ol><p>Python3 solution:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root: Optional[TreeNode])</span> -&gt; bool:</span></span><br><span class="line">    self.balanced = <span class="literal">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">height</span><span class="params">(node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> node:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lh = height(node.left)</span><br><span class="line">        rh = height(node.right)</span><br><span class="line">        <span class="keyword">if</span> abs(lh - rh) &gt; <span class="number">1</span>:</span><br><span class="line">            self.balanced = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> max(lh, rh) + <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    height(root)</span><br><span class="line">    <span class="keyword">return</span> self.balanced</span><br></pre></td></tr></table></figure><p>假設有 n 個 node, 樹的高度為 h</p><ul><li>時間複雜度：O(n)<ul><li>每個節點都做過一次 <code>height</code></li></ul></li><li>空間複雜度：O(h)<ul><li>同 <code>做法一</code> 的分析</li></ul></li></ul><p>類似題：<a href="https://leetcode.com/problems/symmetric-tree/description/">Symmetric Tree</a> 用 recursive 方法來解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/description/&quot;&gt;題目&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;做法一&quot;&gt;&lt;a href=&quot;#做法一&quot; class=&quot;headerlink&quot; title=&quot;做法一&quot;&gt;&lt;/a&gt;做法一&lt;/h3&gt;&lt;p&gt;思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依照 height-balanced 的定義，需要符合&lt;strong&gt;每個&lt;/strong&gt;node 的左右子樹高度差都不大於 1&lt;/li&gt;
&lt;li&gt;假設有個 function &lt;code&gt;height&lt;/code&gt; 可以回傳 node 的 height&lt;ul&gt;
&lt;li&gt;先不實作內容&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用這個 &lt;code&gt;height&lt;/code&gt; 完成 &lt;code&gt;isBalanced&lt;/code&gt;
    
    </summary>
    
    
      <category term="Leetcode" scheme="https://blog.jamesho.website/categories/Leetcode/"/>
    
    
      <category term="tree" scheme="https://blog.jamesho.website/tags/tree/"/>
    
      <category term="depth-first search" scheme="https://blog.jamesho.website/tags/depth-first-search/"/>
    
      <category term="binary tree" scheme="https://blog.jamesho.website/tags/binary-tree/"/>
    
      <category term="recursion" scheme="https://blog.jamesho.website/tags/recursion/"/>
    
  </entry>
  
</feed>
